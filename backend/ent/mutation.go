// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team06/app/ent/appointmentresults"
	"github.com/team06/app/ent/bloodtype"
	"github.com/team06/app/ent/department"
	"github.com/team06/app/ent/diagnosis"
	"github.com/team06/app/ent/doctor"
	"github.com/team06/app/ent/gender"
	"github.com/team06/app/ent/hospital"
	"github.com/team06/app/ent/medicalprocedure"
	"github.com/team06/app/ent/medicalrecord"
	"github.com/team06/app/ent/nurse"
	"github.com/team06/app/ent/patient"
	"github.com/team06/app/ent/predicate"
	"github.com/team06/app/ent/prefix"
	"github.com/team06/app/ent/proceduretype"
	"github.com/team06/app/ent/righttotreatment"
	"github.com/team06/app/ent/righttotreatmenttype"
	"github.com/team06/app/ent/room"
	"github.com/team06/app/ent/treatmenttype"
	"github.com/team06/app/ent/triageresult"
	"github.com/team06/app/ent/urgencylevel"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppointmentResults   = "AppointmentResults"
	TypeBloodType            = "BloodType"
	TypeDepartment           = "Department"
	TypeDiagnosis            = "Diagnosis"
	TypeDoctor               = "Doctor"
	TypeGender               = "Gender"
	TypeHospital             = "Hospital"
	TypeMedicalProcedure     = "MedicalProcedure"
	TypeMedicalRecord        = "MedicalRecord"
	TypeNurse                = "Nurse"
	TypePatient              = "Patient"
	TypePrefix               = "Prefix"
	TypeProcedureType        = "ProcedureType"
	TypeRightToTreatment     = "RightToTreatment"
	TypeRightToTreatmentType = "RightToTreatmentType"
	TypeRoom                 = "Room"
	TypeTreatmentType        = "TreatmentType"
	TypeTriageResult         = "TriageResult"
	TypeUrgencyLevel         = "UrgencyLevel"
)

// AppointmentResultsMutation represents an operation that mutates the AppointmentResults nodes in the graph.
type AppointmentResultsMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	addtimeAppoint                     *time.Time
	addtimeSave                        *time.Time
	clearedFields                      map[string]struct{}
	appointmentResultsToPatient        *int
	clearedappointmentResultsToPatient bool
	appointmentResultsToNurse          *int
	clearedappointmentResultsToNurse   bool
	appointmentResultsToDoctor         *int
	clearedappointmentResultsToDoctor  bool
	appointmentResultsToRoom           *int
	clearedappointmentResultsToRoom    bool
	done                               bool
	oldValue                           func(context.Context) (*AppointmentResults, error)
	predicates                         []predicate.AppointmentResults
}

var _ ent.Mutation = (*AppointmentResultsMutation)(nil)

// appointmentresultsOption allows management of the mutation configuration using functional options.
type appointmentresultsOption func(*AppointmentResultsMutation)

// newAppointmentResultsMutation creates new mutation for the AppointmentResults entity.
func newAppointmentResultsMutation(c config, op Op, opts ...appointmentresultsOption) *AppointmentResultsMutation {
	m := &AppointmentResultsMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointmentResults,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentResultsID sets the ID field of the mutation.
func withAppointmentResultsID(id int) appointmentresultsOption {
	return func(m *AppointmentResultsMutation) {
		var (
			err   error
			once  sync.Once
			value *AppointmentResults
		)
		m.oldValue = func(ctx context.Context) (*AppointmentResults, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppointmentResults.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointmentResults sets the old AppointmentResults of the mutation.
func withAppointmentResults(node *AppointmentResults) appointmentresultsOption {
	return func(m *AppointmentResultsMutation) {
		m.oldValue = func(context.Context) (*AppointmentResults, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentResultsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentResultsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AppointmentResultsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddtimeAppoint sets the "addtimeAppoint" field.
func (m *AppointmentResultsMutation) SetAddtimeAppoint(t time.Time) {
	m.addtimeAppoint = &t
}

// AddtimeAppoint returns the value of the "addtimeAppoint" field in the mutation.
func (m *AppointmentResultsMutation) AddtimeAppoint() (r time.Time, exists bool) {
	v := m.addtimeAppoint
	if v == nil {
		return
	}
	return *v, true
}

// OldAddtimeAppoint returns the old "addtimeAppoint" field's value of the AppointmentResults entity.
// If the AppointmentResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentResultsMutation) OldAddtimeAppoint(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddtimeAppoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddtimeAppoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddtimeAppoint: %w", err)
	}
	return oldValue.AddtimeAppoint, nil
}

// ResetAddtimeAppoint resets all changes to the "addtimeAppoint" field.
func (m *AppointmentResultsMutation) ResetAddtimeAppoint() {
	m.addtimeAppoint = nil
}

// SetAddtimeSave sets the "addtimeSave" field.
func (m *AppointmentResultsMutation) SetAddtimeSave(t time.Time) {
	m.addtimeSave = &t
}

// AddtimeSave returns the value of the "addtimeSave" field in the mutation.
func (m *AppointmentResultsMutation) AddtimeSave() (r time.Time, exists bool) {
	v := m.addtimeSave
	if v == nil {
		return
	}
	return *v, true
}

// OldAddtimeSave returns the old "addtimeSave" field's value of the AppointmentResults entity.
// If the AppointmentResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentResultsMutation) OldAddtimeSave(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddtimeSave is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddtimeSave requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddtimeSave: %w", err)
	}
	return oldValue.AddtimeSave, nil
}

// ResetAddtimeSave resets all changes to the "addtimeSave" field.
func (m *AppointmentResultsMutation) ResetAddtimeSave() {
	m.addtimeSave = nil
}

// SetAppointmentResultsToPatientID sets the "appointmentResultsToPatient" edge to the Patient entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToPatientID(id int) {
	m.appointmentResultsToPatient = &id
}

// ClearAppointmentResultsToPatient clears the "appointmentResultsToPatient" edge to the Patient entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToPatient() {
	m.clearedappointmentResultsToPatient = true
}

// AppointmentResultsToPatientCleared returns if the "appointmentResultsToPatient" edge to the Patient entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToPatientCleared() bool {
	return m.clearedappointmentResultsToPatient
}

// AppointmentResultsToPatientID returns the "appointmentResultsToPatient" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToPatientID() (id int, exists bool) {
	if m.appointmentResultsToPatient != nil {
		return *m.appointmentResultsToPatient, true
	}
	return
}

// AppointmentResultsToPatientIDs returns the "appointmentResultsToPatient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToPatientID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToPatientIDs() (ids []int) {
	if id := m.appointmentResultsToPatient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToPatient resets all changes to the "appointmentResultsToPatient" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToPatient() {
	m.appointmentResultsToPatient = nil
	m.clearedappointmentResultsToPatient = false
}

// SetAppointmentResultsToNurseID sets the "appointmentResultsToNurse" edge to the Nurse entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToNurseID(id int) {
	m.appointmentResultsToNurse = &id
}

// ClearAppointmentResultsToNurse clears the "appointmentResultsToNurse" edge to the Nurse entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToNurse() {
	m.clearedappointmentResultsToNurse = true
}

// AppointmentResultsToNurseCleared returns if the "appointmentResultsToNurse" edge to the Nurse entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToNurseCleared() bool {
	return m.clearedappointmentResultsToNurse
}

// AppointmentResultsToNurseID returns the "appointmentResultsToNurse" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToNurseID() (id int, exists bool) {
	if m.appointmentResultsToNurse != nil {
		return *m.appointmentResultsToNurse, true
	}
	return
}

// AppointmentResultsToNurseIDs returns the "appointmentResultsToNurse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToNurseID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToNurseIDs() (ids []int) {
	if id := m.appointmentResultsToNurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToNurse resets all changes to the "appointmentResultsToNurse" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToNurse() {
	m.appointmentResultsToNurse = nil
	m.clearedappointmentResultsToNurse = false
}

// SetAppointmentResultsToDoctorID sets the "appointmentResultsToDoctor" edge to the Doctor entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToDoctorID(id int) {
	m.appointmentResultsToDoctor = &id
}

// ClearAppointmentResultsToDoctor clears the "appointmentResultsToDoctor" edge to the Doctor entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToDoctor() {
	m.clearedappointmentResultsToDoctor = true
}

// AppointmentResultsToDoctorCleared returns if the "appointmentResultsToDoctor" edge to the Doctor entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToDoctorCleared() bool {
	return m.clearedappointmentResultsToDoctor
}

// AppointmentResultsToDoctorID returns the "appointmentResultsToDoctor" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToDoctorID() (id int, exists bool) {
	if m.appointmentResultsToDoctor != nil {
		return *m.appointmentResultsToDoctor, true
	}
	return
}

// AppointmentResultsToDoctorIDs returns the "appointmentResultsToDoctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToDoctorID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToDoctorIDs() (ids []int) {
	if id := m.appointmentResultsToDoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToDoctor resets all changes to the "appointmentResultsToDoctor" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToDoctor() {
	m.appointmentResultsToDoctor = nil
	m.clearedappointmentResultsToDoctor = false
}

// SetAppointmentResultsToRoomID sets the "appointmentResultsToRoom" edge to the Room entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToRoomID(id int) {
	m.appointmentResultsToRoom = &id
}

// ClearAppointmentResultsToRoom clears the "appointmentResultsToRoom" edge to the Room entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToRoom() {
	m.clearedappointmentResultsToRoom = true
}

// AppointmentResultsToRoomCleared returns if the "appointmentResultsToRoom" edge to the Room entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToRoomCleared() bool {
	return m.clearedappointmentResultsToRoom
}

// AppointmentResultsToRoomID returns the "appointmentResultsToRoom" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToRoomID() (id int, exists bool) {
	if m.appointmentResultsToRoom != nil {
		return *m.appointmentResultsToRoom, true
	}
	return
}

// AppointmentResultsToRoomIDs returns the "appointmentResultsToRoom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToRoomID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToRoomIDs() (ids []int) {
	if id := m.appointmentResultsToRoom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToRoom resets all changes to the "appointmentResultsToRoom" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToRoom() {
	m.appointmentResultsToRoom = nil
	m.clearedappointmentResultsToRoom = false
}

// Op returns the operation name.
func (m *AppointmentResultsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppointmentResults).
func (m *AppointmentResultsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppointmentResultsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.addtimeAppoint != nil {
		fields = append(fields, appointmentresults.FieldAddtimeAppoint)
	}
	if m.addtimeSave != nil {
		fields = append(fields, appointmentresults.FieldAddtimeSave)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppointmentResultsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		return m.AddtimeAppoint()
	case appointmentresults.FieldAddtimeSave:
		return m.AddtimeSave()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppointmentResultsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		return m.OldAddtimeAppoint(ctx)
	case appointmentresults.FieldAddtimeSave:
		return m.OldAddtimeSave(ctx)
	}
	return nil, fmt.Errorf("unknown AppointmentResults field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentResultsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddtimeAppoint(v)
		return nil
	case appointmentresults.FieldAddtimeSave:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddtimeSave(v)
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppointmentResultsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppointmentResultsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentResultsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppointmentResults numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppointmentResultsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppointmentResultsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentResultsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppointmentResults nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppointmentResultsMutation) ResetField(name string) error {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		m.ResetAddtimeAppoint()
		return nil
	case appointmentresults.FieldAddtimeSave:
		m.ResetAddtimeSave()
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppointmentResultsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.appointmentResultsToPatient != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToPatient)
	}
	if m.appointmentResultsToNurse != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToNurse)
	}
	if m.appointmentResultsToDoctor != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToDoctor)
	}
	if m.appointmentResultsToRoom != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToRoom)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppointmentResultsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		if id := m.appointmentResultsToPatient; id != nil {
			return []ent.Value{*id}
		}
	case appointmentresults.EdgeAppointmentResultsToNurse:
		if id := m.appointmentResultsToNurse; id != nil {
			return []ent.Value{*id}
		}
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		if id := m.appointmentResultsToDoctor; id != nil {
			return []ent.Value{*id}
		}
	case appointmentresults.EdgeAppointmentResultsToRoom:
		if id := m.appointmentResultsToRoom; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppointmentResultsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppointmentResultsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppointmentResultsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedappointmentResultsToPatient {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToPatient)
	}
	if m.clearedappointmentResultsToNurse {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToNurse)
	}
	if m.clearedappointmentResultsToDoctor {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToDoctor)
	}
	if m.clearedappointmentResultsToRoom {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToRoom)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppointmentResultsMutation) EdgeCleared(name string) bool {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		return m.clearedappointmentResultsToPatient
	case appointmentresults.EdgeAppointmentResultsToNurse:
		return m.clearedappointmentResultsToNurse
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		return m.clearedappointmentResultsToDoctor
	case appointmentresults.EdgeAppointmentResultsToRoom:
		return m.clearedappointmentResultsToRoom
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppointmentResultsMutation) ClearEdge(name string) error {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		m.ClearAppointmentResultsToPatient()
		return nil
	case appointmentresults.EdgeAppointmentResultsToNurse:
		m.ClearAppointmentResultsToNurse()
		return nil
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		m.ClearAppointmentResultsToDoctor()
		return nil
	case appointmentresults.EdgeAppointmentResultsToRoom:
		m.ClearAppointmentResultsToRoom()
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppointmentResultsMutation) ResetEdge(name string) error {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		m.ResetAppointmentResultsToPatient()
		return nil
	case appointmentresults.EdgeAppointmentResultsToNurse:
		m.ResetAppointmentResultsToNurse()
		return nil
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		m.ResetAppointmentResultsToDoctor()
		return nil
	case appointmentresults.EdgeAppointmentResultsToRoom:
		m.ResetAppointmentResultsToRoom()
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults edge %s", name)
}

// BloodTypeMutation represents an operation that mutates the BloodType nodes in the graph.
type BloodTypeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	bloodValue      *string
	clearedFields   map[string]struct{}
	patients        map[int]struct{}
	removedpatients map[int]struct{}
	clearedpatients bool
	done            bool
	oldValue        func(context.Context) (*BloodType, error)
	predicates      []predicate.BloodType
}

var _ ent.Mutation = (*BloodTypeMutation)(nil)

// bloodtypeOption allows management of the mutation configuration using functional options.
type bloodtypeOption func(*BloodTypeMutation)

// newBloodTypeMutation creates new mutation for the BloodType entity.
func newBloodTypeMutation(c config, op Op, opts ...bloodtypeOption) *BloodTypeMutation {
	m := &BloodTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBloodType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBloodTypeID sets the ID field of the mutation.
func withBloodTypeID(id int) bloodtypeOption {
	return func(m *BloodTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *BloodType
		)
		m.oldValue = func(ctx context.Context) (*BloodType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BloodType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBloodType sets the old BloodType of the mutation.
func withBloodType(node *BloodType) bloodtypeOption {
	return func(m *BloodTypeMutation) {
		m.oldValue = func(context.Context) (*BloodType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BloodTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BloodTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BloodTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBloodValue sets the "bloodValue" field.
func (m *BloodTypeMutation) SetBloodValue(s string) {
	m.bloodValue = &s
}

// BloodValue returns the value of the "bloodValue" field in the mutation.
func (m *BloodTypeMutation) BloodValue() (r string, exists bool) {
	v := m.bloodValue
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodValue returns the old "bloodValue" field's value of the BloodType entity.
// If the BloodType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BloodTypeMutation) OldBloodValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBloodValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBloodValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodValue: %w", err)
	}
	return oldValue.BloodValue, nil
}

// ResetBloodValue resets all changes to the "bloodValue" field.
func (m *BloodTypeMutation) ResetBloodValue() {
	m.bloodValue = nil
}

// AddPatientIDs adds the "patients" edge to the Patient entity by ids.
func (m *BloodTypeMutation) AddPatientIDs(ids ...int) {
	if m.patients == nil {
		m.patients = make(map[int]struct{})
	}
	for i := range ids {
		m.patients[ids[i]] = struct{}{}
	}
}

// ClearPatients clears the "patients" edge to the Patient entity.
func (m *BloodTypeMutation) ClearPatients() {
	m.clearedpatients = true
}

// PatientsCleared returns if the "patients" edge to the Patient entity was cleared.
func (m *BloodTypeMutation) PatientsCleared() bool {
	return m.clearedpatients
}

// RemovePatientIDs removes the "patients" edge to the Patient entity by IDs.
func (m *BloodTypeMutation) RemovePatientIDs(ids ...int) {
	if m.removedpatients == nil {
		m.removedpatients = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatients[ids[i]] = struct{}{}
	}
}

// RemovedPatients returns the removed IDs of the "patients" edge to the Patient entity.
func (m *BloodTypeMutation) RemovedPatientsIDs() (ids []int) {
	for id := range m.removedpatients {
		ids = append(ids, id)
	}
	return
}

// PatientsIDs returns the "patients" edge IDs in the mutation.
func (m *BloodTypeMutation) PatientsIDs() (ids []int) {
	for id := range m.patients {
		ids = append(ids, id)
	}
	return
}

// ResetPatients resets all changes to the "patients" edge.
func (m *BloodTypeMutation) ResetPatients() {
	m.patients = nil
	m.clearedpatients = false
	m.removedpatients = nil
}

// Op returns the operation name.
func (m *BloodTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BloodType).
func (m *BloodTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BloodTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.bloodValue != nil {
		fields = append(fields, bloodtype.FieldBloodValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BloodTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bloodtype.FieldBloodValue:
		return m.BloodValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BloodTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bloodtype.FieldBloodValue:
		return m.OldBloodValue(ctx)
	}
	return nil, fmt.Errorf("unknown BloodType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BloodTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bloodtype.FieldBloodValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodValue(v)
		return nil
	}
	return fmt.Errorf("unknown BloodType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BloodTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BloodTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BloodTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BloodType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BloodTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BloodTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BloodTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BloodType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BloodTypeMutation) ResetField(name string) error {
	switch name {
	case bloodtype.FieldBloodValue:
		m.ResetBloodValue()
		return nil
	}
	return fmt.Errorf("unknown BloodType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BloodTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.patients != nil {
		edges = append(edges, bloodtype.EdgePatients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BloodTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgePatients:
		ids := make([]ent.Value, 0, len(m.patients))
		for id := range m.patients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BloodTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpatients != nil {
		edges = append(edges, bloodtype.EdgePatients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BloodTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgePatients:
		ids := make([]ent.Value, 0, len(m.removedpatients))
		for id := range m.removedpatients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BloodTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpatients {
		edges = append(edges, bloodtype.EdgePatients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BloodTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case bloodtype.EdgePatients:
		return m.clearedpatients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BloodTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BloodType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BloodTypeMutation) ResetEdge(name string) error {
	switch name {
	case bloodtype.EdgePatients:
		m.ResetPatients()
		return nil
	}
	return fmt.Errorf("unknown BloodType edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	departmentName      *string
	clearedFields       map[string]struct{}
	triageResult        map[int]struct{}
	removedtriageResult map[int]struct{}
	clearedtriageResult bool
	done                bool
	oldValue            func(context.Context) (*Department, error)
	predicates          []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDepartmentName sets the "departmentName" field.
func (m *DepartmentMutation) SetDepartmentName(s string) {
	m.departmentName = &s
}

// DepartmentName returns the value of the "departmentName" field in the mutation.
func (m *DepartmentMutation) DepartmentName() (r string, exists bool) {
	v := m.departmentName
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentName returns the old "departmentName" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDepartmentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepartmentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepartmentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentName: %w", err)
	}
	return oldValue.DepartmentName, nil
}

// ResetDepartmentName resets all changes to the "departmentName" field.
func (m *DepartmentMutation) ResetDepartmentName() {
	m.departmentName = nil
}

// AddTriageResultIDs adds the "triageResult" edge to the TriageResult entity by ids.
func (m *DepartmentMutation) AddTriageResultIDs(ids ...int) {
	if m.triageResult == nil {
		m.triageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.triageResult[ids[i]] = struct{}{}
	}
}

// ClearTriageResult clears the "triageResult" edge to the TriageResult entity.
func (m *DepartmentMutation) ClearTriageResult() {
	m.clearedtriageResult = true
}

// TriageResultCleared returns if the "triageResult" edge to the TriageResult entity was cleared.
func (m *DepartmentMutation) TriageResultCleared() bool {
	return m.clearedtriageResult
}

// RemoveTriageResultIDs removes the "triageResult" edge to the TriageResult entity by IDs.
func (m *DepartmentMutation) RemoveTriageResultIDs(ids ...int) {
	if m.removedtriageResult == nil {
		m.removedtriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtriageResult[ids[i]] = struct{}{}
	}
}

// RemovedTriageResult returns the removed IDs of the "triageResult" edge to the TriageResult entity.
func (m *DepartmentMutation) RemovedTriageResultIDs() (ids []int) {
	for id := range m.removedtriageResult {
		ids = append(ids, id)
	}
	return
}

// TriageResultIDs returns the "triageResult" edge IDs in the mutation.
func (m *DepartmentMutation) TriageResultIDs() (ids []int) {
	for id := range m.triageResult {
		ids = append(ids, id)
	}
	return
}

// ResetTriageResult resets all changes to the "triageResult" edge.
func (m *DepartmentMutation) ResetTriageResult() {
	m.triageResult = nil
	m.clearedtriageResult = false
	m.removedtriageResult = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.departmentName != nil {
		fields = append(fields, department.FieldDepartmentName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDepartmentName:
		return m.DepartmentName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDepartmentName:
		return m.OldDepartmentName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDepartmentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDepartmentName:
		m.ResetDepartmentName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.triageResult != nil {
		edges = append(edges, department.EdgeTriageResult)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.triageResult))
		for id := range m.triageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtriageResult != nil {
		edges = append(edges, department.EdgeTriageResult)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.removedtriageResult))
		for id := range m.removedtriageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtriageResult {
		edges = append(edges, department.EdgeTriageResult)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeTriageResult:
		return m.clearedtriageResult
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeTriageResult:
		m.ResetTriageResult()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DiagnosisMutation represents an operation that mutates the Diagnosis nodes in the graph.
type DiagnosisMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	symptom             *string
	_Opinionresult      *string
	diagnosisDate       *time.Time
	clearedFields       map[string]struct{}
	_Doctor_name        *int
	cleared_Doctor_name bool
	_Patient            *int
	cleared_Patient     bool
	_type               *int
	cleared_type        bool
	done                bool
	oldValue            func(context.Context) (*Diagnosis, error)
	predicates          []predicate.Diagnosis
}

var _ ent.Mutation = (*DiagnosisMutation)(nil)

// diagnosisOption allows management of the mutation configuration using functional options.
type diagnosisOption func(*DiagnosisMutation)

// newDiagnosisMutation creates new mutation for the Diagnosis entity.
func newDiagnosisMutation(c config, op Op, opts ...diagnosisOption) *DiagnosisMutation {
	m := &DiagnosisMutation{
		config:        c,
		op:            op,
		typ:           TypeDiagnosis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiagnosisID sets the ID field of the mutation.
func withDiagnosisID(id int) diagnosisOption {
	return func(m *DiagnosisMutation) {
		var (
			err   error
			once  sync.Once
			value *Diagnosis
		)
		m.oldValue = func(ctx context.Context) (*Diagnosis, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Diagnosis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiagnosis sets the old Diagnosis of the mutation.
func withDiagnosis(node *Diagnosis) diagnosisOption {
	return func(m *DiagnosisMutation) {
		m.oldValue = func(context.Context) (*Diagnosis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiagnosisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiagnosisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DiagnosisMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptom sets the "symptom" field.
func (m *DiagnosisMutation) SetSymptom(s string) {
	m.symptom = &s
}

// Symptom returns the value of the "symptom" field in the mutation.
func (m *DiagnosisMutation) Symptom() (r string, exists bool) {
	v := m.symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old "symptom" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom resets all changes to the "symptom" field.
func (m *DiagnosisMutation) ResetSymptom() {
	m.symptom = nil
}

// SetOpinionresult sets the "Opinionresult" field.
func (m *DiagnosisMutation) SetOpinionresult(s string) {
	m._Opinionresult = &s
}

// Opinionresult returns the value of the "Opinionresult" field in the mutation.
func (m *DiagnosisMutation) Opinionresult() (r string, exists bool) {
	v := m._Opinionresult
	if v == nil {
		return
	}
	return *v, true
}

// OldOpinionresult returns the old "Opinionresult" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldOpinionresult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpinionresult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpinionresult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpinionresult: %w", err)
	}
	return oldValue.Opinionresult, nil
}

// ResetOpinionresult resets all changes to the "Opinionresult" field.
func (m *DiagnosisMutation) ResetOpinionresult() {
	m._Opinionresult = nil
}

// SetDiagnosisDate sets the "diagnosisDate" field.
func (m *DiagnosisMutation) SetDiagnosisDate(t time.Time) {
	m.diagnosisDate = &t
}

// DiagnosisDate returns the value of the "diagnosisDate" field in the mutation.
func (m *DiagnosisMutation) DiagnosisDate() (r time.Time, exists bool) {
	v := m.diagnosisDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagnosisDate returns the old "diagnosisDate" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldDiagnosisDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiagnosisDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiagnosisDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagnosisDate: %w", err)
	}
	return oldValue.DiagnosisDate, nil
}

// ResetDiagnosisDate resets all changes to the "diagnosisDate" field.
func (m *DiagnosisMutation) ResetDiagnosisDate() {
	m.diagnosisDate = nil
}

// SetDoctorNameID sets the "Doctor_name" edge to the Doctor entity by id.
func (m *DiagnosisMutation) SetDoctorNameID(id int) {
	m._Doctor_name = &id
}

// ClearDoctorName clears the "Doctor_name" edge to the Doctor entity.
func (m *DiagnosisMutation) ClearDoctorName() {
	m.cleared_Doctor_name = true
}

// DoctorNameCleared returns if the "Doctor_name" edge to the Doctor entity was cleared.
func (m *DiagnosisMutation) DoctorNameCleared() bool {
	return m.cleared_Doctor_name
}

// DoctorNameID returns the "Doctor_name" edge ID in the mutation.
func (m *DiagnosisMutation) DoctorNameID() (id int, exists bool) {
	if m._Doctor_name != nil {
		return *m._Doctor_name, true
	}
	return
}

// DoctorNameIDs returns the "Doctor_name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorNameID instead. It exists only for internal usage by the builders.
func (m *DiagnosisMutation) DoctorNameIDs() (ids []int) {
	if id := m._Doctor_name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctorName resets all changes to the "Doctor_name" edge.
func (m *DiagnosisMutation) ResetDoctorName() {
	m._Doctor_name = nil
	m.cleared_Doctor_name = false
}

// SetPatientID sets the "Patient" edge to the Patient entity by id.
func (m *DiagnosisMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the "Patient" edge to the Patient entity.
func (m *DiagnosisMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the "Patient" edge to the Patient entity was cleared.
func (m *DiagnosisMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the "Patient" edge ID in the mutation.
func (m *DiagnosisMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the "Patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *DiagnosisMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "Patient" edge.
func (m *DiagnosisMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// SetTypeID sets the "type" edge to the TreatmentType entity by id.
func (m *DiagnosisMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the TreatmentType entity.
func (m *DiagnosisMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the "type" edge to the TreatmentType entity was cleared.
func (m *DiagnosisMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *DiagnosisMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *DiagnosisMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *DiagnosisMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Op returns the operation name.
func (m *DiagnosisMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Diagnosis).
func (m *DiagnosisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiagnosisMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.symptom != nil {
		fields = append(fields, diagnosis.FieldSymptom)
	}
	if m._Opinionresult != nil {
		fields = append(fields, diagnosis.FieldOpinionresult)
	}
	if m.diagnosisDate != nil {
		fields = append(fields, diagnosis.FieldDiagnosisDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiagnosisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case diagnosis.FieldSymptom:
		return m.Symptom()
	case diagnosis.FieldOpinionresult:
		return m.Opinionresult()
	case diagnosis.FieldDiagnosisDate:
		return m.DiagnosisDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiagnosisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case diagnosis.FieldSymptom:
		return m.OldSymptom(ctx)
	case diagnosis.FieldOpinionresult:
		return m.OldOpinionresult(ctx)
	case diagnosis.FieldDiagnosisDate:
		return m.OldDiagnosisDate(ctx)
	}
	return nil, fmt.Errorf("unknown Diagnosis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case diagnosis.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case diagnosis.FieldOpinionresult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpinionresult(v)
		return nil
	case diagnosis.FieldDiagnosisDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagnosisDate(v)
		return nil
	}
	return fmt.Errorf("unknown Diagnosis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiagnosisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiagnosisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Diagnosis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiagnosisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiagnosisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiagnosisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Diagnosis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiagnosisMutation) ResetField(name string) error {
	switch name {
	case diagnosis.FieldSymptom:
		m.ResetSymptom()
		return nil
	case diagnosis.FieldOpinionresult:
		m.ResetOpinionresult()
		return nil
	case diagnosis.FieldDiagnosisDate:
		m.ResetDiagnosisDate()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiagnosisMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Doctor_name != nil {
		edges = append(edges, diagnosis.EdgeDoctorName)
	}
	if m._Patient != nil {
		edges = append(edges, diagnosis.EdgePatient)
	}
	if m._type != nil {
		edges = append(edges, diagnosis.EdgeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiagnosisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case diagnosis.EdgeDoctorName:
		if id := m._Doctor_name; id != nil {
			return []ent.Value{*id}
		}
	case diagnosis.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	case diagnosis.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiagnosisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiagnosisMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiagnosisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Doctor_name {
		edges = append(edges, diagnosis.EdgeDoctorName)
	}
	if m.cleared_Patient {
		edges = append(edges, diagnosis.EdgePatient)
	}
	if m.cleared_type {
		edges = append(edges, diagnosis.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiagnosisMutation) EdgeCleared(name string) bool {
	switch name {
	case diagnosis.EdgeDoctorName:
		return m.cleared_Doctor_name
	case diagnosis.EdgePatient:
		return m.cleared_Patient
	case diagnosis.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiagnosisMutation) ClearEdge(name string) error {
	switch name {
	case diagnosis.EdgeDoctorName:
		m.ClearDoctorName()
		return nil
	case diagnosis.EdgePatient:
		m.ClearPatient()
		return nil
	case diagnosis.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiagnosisMutation) ResetEdge(name string) error {
	switch name {
	case diagnosis.EdgeDoctorName:
		m.ResetDoctorName()
		return nil
	case diagnosis.EdgePatient:
		m.ResetPatient()
		return nil
	case diagnosis.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis edge %s", name)
}

// DoctorMutation represents an operation that mutates the Doctor nodes in the graph.
type DoctorMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	doctorName                         *string
	doctorUsername                     *string
	doctorPassword                     *string
	clearedFields                      map[string]struct{}
	_DoctorToDiagnosis                 map[int]struct{}
	removed_DoctorToDiagnosis          map[int]struct{}
	cleared_DoctorToDiagnosis          bool
	_DoctorToAppointmentResults        map[int]struct{}
	removed_DoctorToAppointmentResults map[int]struct{}
	cleared_DoctorToAppointmentResults bool
	_DoctorToMedicalProcedure          map[int]struct{}
	removed_DoctorToMedicalProcedure   map[int]struct{}
	cleared_DoctorToMedicalProcedure   bool
	done                               bool
	oldValue                           func(context.Context) (*Doctor, error)
	predicates                         []predicate.Doctor
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows management of the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for the Doctor entity.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the ID field of the mutation.
func withDoctorID(id int) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDoctorName sets the "doctorName" field.
func (m *DoctorMutation) SetDoctorName(s string) {
	m.doctorName = &s
}

// DoctorName returns the value of the "doctorName" field in the mutation.
func (m *DoctorMutation) DoctorName() (r string, exists bool) {
	v := m.doctorName
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorName returns the old "doctorName" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDoctorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorName: %w", err)
	}
	return oldValue.DoctorName, nil
}

// ResetDoctorName resets all changes to the "doctorName" field.
func (m *DoctorMutation) ResetDoctorName() {
	m.doctorName = nil
}

// SetDoctorUsername sets the "doctorUsername" field.
func (m *DoctorMutation) SetDoctorUsername(s string) {
	m.doctorUsername = &s
}

// DoctorUsername returns the value of the "doctorUsername" field in the mutation.
func (m *DoctorMutation) DoctorUsername() (r string, exists bool) {
	v := m.doctorUsername
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorUsername returns the old "doctorUsername" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDoctorUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorUsername: %w", err)
	}
	return oldValue.DoctorUsername, nil
}

// ResetDoctorUsername resets all changes to the "doctorUsername" field.
func (m *DoctorMutation) ResetDoctorUsername() {
	m.doctorUsername = nil
}

// SetDoctorPassword sets the "doctorPassword" field.
func (m *DoctorMutation) SetDoctorPassword(s string) {
	m.doctorPassword = &s
}

// DoctorPassword returns the value of the "doctorPassword" field in the mutation.
func (m *DoctorMutation) DoctorPassword() (r string, exists bool) {
	v := m.doctorPassword
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorPassword returns the old "doctorPassword" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDoctorPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorPassword: %w", err)
	}
	return oldValue.DoctorPassword, nil
}

// ResetDoctorPassword resets all changes to the "doctorPassword" field.
func (m *DoctorMutation) ResetDoctorPassword() {
	m.doctorPassword = nil
}

// AddDoctorToDiagnosiIDs adds the "DoctorToDiagnosis" edge to the Diagnosis entity by ids.
func (m *DoctorMutation) AddDoctorToDiagnosiIDs(ids ...int) {
	if m._DoctorToDiagnosis == nil {
		m._DoctorToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m._DoctorToDiagnosis[ids[i]] = struct{}{}
	}
}

// ClearDoctorToDiagnosis clears the "DoctorToDiagnosis" edge to the Diagnosis entity.
func (m *DoctorMutation) ClearDoctorToDiagnosis() {
	m.cleared_DoctorToDiagnosis = true
}

// DoctorToDiagnosisCleared returns if the "DoctorToDiagnosis" edge to the Diagnosis entity was cleared.
func (m *DoctorMutation) DoctorToDiagnosisCleared() bool {
	return m.cleared_DoctorToDiagnosis
}

// RemoveDoctorToDiagnosiIDs removes the "DoctorToDiagnosis" edge to the Diagnosis entity by IDs.
func (m *DoctorMutation) RemoveDoctorToDiagnosiIDs(ids ...int) {
	if m.removed_DoctorToDiagnosis == nil {
		m.removed_DoctorToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DoctorToDiagnosis[ids[i]] = struct{}{}
	}
}

// RemovedDoctorToDiagnosis returns the removed IDs of the "DoctorToDiagnosis" edge to the Diagnosis entity.
func (m *DoctorMutation) RemovedDoctorToDiagnosisIDs() (ids []int) {
	for id := range m.removed_DoctorToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// DoctorToDiagnosisIDs returns the "DoctorToDiagnosis" edge IDs in the mutation.
func (m *DoctorMutation) DoctorToDiagnosisIDs() (ids []int) {
	for id := range m._DoctorToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorToDiagnosis resets all changes to the "DoctorToDiagnosis" edge.
func (m *DoctorMutation) ResetDoctorToDiagnosis() {
	m._DoctorToDiagnosis = nil
	m.cleared_DoctorToDiagnosis = false
	m.removed_DoctorToDiagnosis = nil
}

// AddDoctorToAppointmentResultIDs adds the "DoctorToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *DoctorMutation) AddDoctorToAppointmentResultIDs(ids ...int) {
	if m._DoctorToAppointmentResults == nil {
		m._DoctorToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._DoctorToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearDoctorToAppointmentResults clears the "DoctorToAppointmentResults" edge to the AppointmentResults entity.
func (m *DoctorMutation) ClearDoctorToAppointmentResults() {
	m.cleared_DoctorToAppointmentResults = true
}

// DoctorToAppointmentResultsCleared returns if the "DoctorToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *DoctorMutation) DoctorToAppointmentResultsCleared() bool {
	return m.cleared_DoctorToAppointmentResults
}

// RemoveDoctorToAppointmentResultIDs removes the "DoctorToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *DoctorMutation) RemoveDoctorToAppointmentResultIDs(ids ...int) {
	if m.removed_DoctorToAppointmentResults == nil {
		m.removed_DoctorToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DoctorToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedDoctorToAppointmentResults returns the removed IDs of the "DoctorToAppointmentResults" edge to the AppointmentResults entity.
func (m *DoctorMutation) RemovedDoctorToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_DoctorToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// DoctorToAppointmentResultsIDs returns the "DoctorToAppointmentResults" edge IDs in the mutation.
func (m *DoctorMutation) DoctorToAppointmentResultsIDs() (ids []int) {
	for id := range m._DoctorToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorToAppointmentResults resets all changes to the "DoctorToAppointmentResults" edge.
func (m *DoctorMutation) ResetDoctorToAppointmentResults() {
	m._DoctorToAppointmentResults = nil
	m.cleared_DoctorToAppointmentResults = false
	m.removed_DoctorToAppointmentResults = nil
}

// AddDoctorToMedicalProcedureIDs adds the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity by ids.
func (m *DoctorMutation) AddDoctorToMedicalProcedureIDs(ids ...int) {
	if m._DoctorToMedicalProcedure == nil {
		m._DoctorToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m._DoctorToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// ClearDoctorToMedicalProcedure clears the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *DoctorMutation) ClearDoctorToMedicalProcedure() {
	m.cleared_DoctorToMedicalProcedure = true
}

// DoctorToMedicalProcedureCleared returns if the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity was cleared.
func (m *DoctorMutation) DoctorToMedicalProcedureCleared() bool {
	return m.cleared_DoctorToMedicalProcedure
}

// RemoveDoctorToMedicalProcedureIDs removes the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity by IDs.
func (m *DoctorMutation) RemoveDoctorToMedicalProcedureIDs(ids ...int) {
	if m.removed_DoctorToMedicalProcedure == nil {
		m.removed_DoctorToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DoctorToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// RemovedDoctorToMedicalProcedure returns the removed IDs of the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *DoctorMutation) RemovedDoctorToMedicalProcedureIDs() (ids []int) {
	for id := range m.removed_DoctorToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// DoctorToMedicalProcedureIDs returns the "DoctorToMedicalProcedure" edge IDs in the mutation.
func (m *DoctorMutation) DoctorToMedicalProcedureIDs() (ids []int) {
	for id := range m._DoctorToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorToMedicalProcedure resets all changes to the "DoctorToMedicalProcedure" edge.
func (m *DoctorMutation) ResetDoctorToMedicalProcedure() {
	m._DoctorToMedicalProcedure = nil
	m.cleared_DoctorToMedicalProcedure = false
	m.removed_DoctorToMedicalProcedure = nil
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.doctorName != nil {
		fields = append(fields, doctor.FieldDoctorName)
	}
	if m.doctorUsername != nil {
		fields = append(fields, doctor.FieldDoctorUsername)
	}
	if m.doctorPassword != nil {
		fields = append(fields, doctor.FieldDoctorPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldDoctorName:
		return m.DoctorName()
	case doctor.FieldDoctorUsername:
		return m.DoctorUsername()
	case doctor.FieldDoctorPassword:
		return m.DoctorPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldDoctorName:
		return m.OldDoctorName(ctx)
	case doctor.FieldDoctorUsername:
		return m.OldDoctorUsername(ctx)
	case doctor.FieldDoctorPassword:
		return m.OldDoctorPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldDoctorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorName(v)
		return nil
	case doctor.FieldDoctorUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorUsername(v)
		return nil
	case doctor.FieldDoctorPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldDoctorName:
		m.ResetDoctorName()
		return nil
	case doctor.FieldDoctorUsername:
		m.ResetDoctorUsername()
		return nil
	case doctor.FieldDoctorPassword:
		m.ResetDoctorPassword()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._DoctorToDiagnosis != nil {
		edges = append(edges, doctor.EdgeDoctorToDiagnosis)
	}
	if m._DoctorToAppointmentResults != nil {
		edges = append(edges, doctor.EdgeDoctorToAppointmentResults)
	}
	if m._DoctorToMedicalProcedure != nil {
		edges = append(edges, doctor.EdgeDoctorToMedicalProcedure)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		ids := make([]ent.Value, 0, len(m._DoctorToDiagnosis))
		for id := range m._DoctorToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._DoctorToAppointmentResults))
		for id := range m._DoctorToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m._DoctorToMedicalProcedure))
		for id := range m._DoctorToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_DoctorToDiagnosis != nil {
		edges = append(edges, doctor.EdgeDoctorToDiagnosis)
	}
	if m.removed_DoctorToAppointmentResults != nil {
		edges = append(edges, doctor.EdgeDoctorToAppointmentResults)
	}
	if m.removed_DoctorToMedicalProcedure != nil {
		edges = append(edges, doctor.EdgeDoctorToMedicalProcedure)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		ids := make([]ent.Value, 0, len(m.removed_DoctorToDiagnosis))
		for id := range m.removed_DoctorToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_DoctorToAppointmentResults))
		for id := range m.removed_DoctorToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m.removed_DoctorToMedicalProcedure))
		for id := range m.removed_DoctorToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_DoctorToDiagnosis {
		edges = append(edges, doctor.EdgeDoctorToDiagnosis)
	}
	if m.cleared_DoctorToAppointmentResults {
		edges = append(edges, doctor.EdgeDoctorToAppointmentResults)
	}
	if m.cleared_DoctorToMedicalProcedure {
		edges = append(edges, doctor.EdgeDoctorToMedicalProcedure)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		return m.cleared_DoctorToDiagnosis
	case doctor.EdgeDoctorToAppointmentResults:
		return m.cleared_DoctorToAppointmentResults
	case doctor.EdgeDoctorToMedicalProcedure:
		return m.cleared_DoctorToMedicalProcedure
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		m.ResetDoctorToDiagnosis()
		return nil
	case doctor.EdgeDoctorToAppointmentResults:
		m.ResetDoctorToAppointmentResults()
		return nil
	case doctor.EdgeDoctorToMedicalProcedure:
		m.ResetDoctorToMedicalProcedure()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// GenderMutation represents an operation that mutates the Gender nodes in the graph.
type GenderMutation struct {
	config
	op              Op
	typ             string
	id              *int
	genderValue     *string
	clearedFields   map[string]struct{}
	patients        map[int]struct{}
	removedpatients map[int]struct{}
	clearedpatients bool
	done            bool
	oldValue        func(context.Context) (*Gender, error)
	predicates      []predicate.Gender
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows management of the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for the Gender entity.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the ID field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGenderValue sets the "genderValue" field.
func (m *GenderMutation) SetGenderValue(s string) {
	m.genderValue = &s
}

// GenderValue returns the value of the "genderValue" field in the mutation.
func (m *GenderMutation) GenderValue() (r string, exists bool) {
	v := m.genderValue
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderValue returns the old "genderValue" field's value of the Gender entity.
// If the Gender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenderMutation) OldGenderValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderValue: %w", err)
	}
	return oldValue.GenderValue, nil
}

// ResetGenderValue resets all changes to the "genderValue" field.
func (m *GenderMutation) ResetGenderValue() {
	m.genderValue = nil
}

// AddPatientIDs adds the "patients" edge to the Patient entity by ids.
func (m *GenderMutation) AddPatientIDs(ids ...int) {
	if m.patients == nil {
		m.patients = make(map[int]struct{})
	}
	for i := range ids {
		m.patients[ids[i]] = struct{}{}
	}
}

// ClearPatients clears the "patients" edge to the Patient entity.
func (m *GenderMutation) ClearPatients() {
	m.clearedpatients = true
}

// PatientsCleared returns if the "patients" edge to the Patient entity was cleared.
func (m *GenderMutation) PatientsCleared() bool {
	return m.clearedpatients
}

// RemovePatientIDs removes the "patients" edge to the Patient entity by IDs.
func (m *GenderMutation) RemovePatientIDs(ids ...int) {
	if m.removedpatients == nil {
		m.removedpatients = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatients[ids[i]] = struct{}{}
	}
}

// RemovedPatients returns the removed IDs of the "patients" edge to the Patient entity.
func (m *GenderMutation) RemovedPatientsIDs() (ids []int) {
	for id := range m.removedpatients {
		ids = append(ids, id)
	}
	return
}

// PatientsIDs returns the "patients" edge IDs in the mutation.
func (m *GenderMutation) PatientsIDs() (ids []int) {
	for id := range m.patients {
		ids = append(ids, id)
	}
	return
}

// ResetPatients resets all changes to the "patients" edge.
func (m *GenderMutation) ResetPatients() {
	m.patients = nil
	m.clearedpatients = false
	m.removedpatients = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.genderValue != nil {
		fields = append(fields, gender.FieldGenderValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGenderValue:
		return m.GenderValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGenderValue:
		return m.OldGenderValue(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGenderValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderValue(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGenderValue:
		m.ResetGenderValue()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.patients != nil {
		edges = append(edges, gender.EdgePatients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgePatients:
		ids := make([]ent.Value, 0, len(m.patients))
		for id := range m.patients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpatients != nil {
		edges = append(edges, gender.EdgePatients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgePatients:
		ids := make([]ent.Value, 0, len(m.removedpatients))
		for id := range m.removedpatients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpatients {
		edges = append(edges, gender.EdgePatients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	case gender.EdgePatients:
		return m.clearedpatients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgePatients:
		m.ResetPatients()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// HospitalMutation represents an operation that mutates the Hospital nodes in the graph.
type HospitalMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_HospitalName   *string
	clearedFields   map[string]struct{}
	hospital        map[int]struct{}
	removedhospital map[int]struct{}
	clearedhospital bool
	done            bool
	oldValue        func(context.Context) (*Hospital, error)
	predicates      []predicate.Hospital
}

var _ ent.Mutation = (*HospitalMutation)(nil)

// hospitalOption allows management of the mutation configuration using functional options.
type hospitalOption func(*HospitalMutation)

// newHospitalMutation creates new mutation for the Hospital entity.
func newHospitalMutation(c config, op Op, opts ...hospitalOption) *HospitalMutation {
	m := &HospitalMutation{
		config:        c,
		op:            op,
		typ:           TypeHospital,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHospitalID sets the ID field of the mutation.
func withHospitalID(id int) hospitalOption {
	return func(m *HospitalMutation) {
		var (
			err   error
			once  sync.Once
			value *Hospital
		)
		m.oldValue = func(ctx context.Context) (*Hospital, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hospital.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHospital sets the old Hospital of the mutation.
func withHospital(node *Hospital) hospitalOption {
	return func(m *HospitalMutation) {
		m.oldValue = func(context.Context) (*Hospital, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HospitalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HospitalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HospitalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHospitalName sets the "HospitalName" field.
func (m *HospitalMutation) SetHospitalName(s string) {
	m._HospitalName = &s
}

// HospitalName returns the value of the "HospitalName" field in the mutation.
func (m *HospitalMutation) HospitalName() (r string, exists bool) {
	v := m._HospitalName
	if v == nil {
		return
	}
	return *v, true
}

// OldHospitalName returns the old "HospitalName" field's value of the Hospital entity.
// If the Hospital object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HospitalMutation) OldHospitalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHospitalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHospitalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHospitalName: %w", err)
	}
	return oldValue.HospitalName, nil
}

// ResetHospitalName resets all changes to the "HospitalName" field.
func (m *HospitalMutation) ResetHospitalName() {
	m._HospitalName = nil
}

// AddHospitalIDs adds the "hospital" edge to the RightToTreatment entity by ids.
func (m *HospitalMutation) AddHospitalIDs(ids ...int) {
	if m.hospital == nil {
		m.hospital = make(map[int]struct{})
	}
	for i := range ids {
		m.hospital[ids[i]] = struct{}{}
	}
}

// ClearHospital clears the "hospital" edge to the RightToTreatment entity.
func (m *HospitalMutation) ClearHospital() {
	m.clearedhospital = true
}

// HospitalCleared returns if the "hospital" edge to the RightToTreatment entity was cleared.
func (m *HospitalMutation) HospitalCleared() bool {
	return m.clearedhospital
}

// RemoveHospitalIDs removes the "hospital" edge to the RightToTreatment entity by IDs.
func (m *HospitalMutation) RemoveHospitalIDs(ids ...int) {
	if m.removedhospital == nil {
		m.removedhospital = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhospital[ids[i]] = struct{}{}
	}
}

// RemovedHospital returns the removed IDs of the "hospital" edge to the RightToTreatment entity.
func (m *HospitalMutation) RemovedHospitalIDs() (ids []int) {
	for id := range m.removedhospital {
		ids = append(ids, id)
	}
	return
}

// HospitalIDs returns the "hospital" edge IDs in the mutation.
func (m *HospitalMutation) HospitalIDs() (ids []int) {
	for id := range m.hospital {
		ids = append(ids, id)
	}
	return
}

// ResetHospital resets all changes to the "hospital" edge.
func (m *HospitalMutation) ResetHospital() {
	m.hospital = nil
	m.clearedhospital = false
	m.removedhospital = nil
}

// Op returns the operation name.
func (m *HospitalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hospital).
func (m *HospitalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HospitalMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._HospitalName != nil {
		fields = append(fields, hospital.FieldHospitalName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HospitalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hospital.FieldHospitalName:
		return m.HospitalName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HospitalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hospital.FieldHospitalName:
		return m.OldHospitalName(ctx)
	}
	return nil, fmt.Errorf("unknown Hospital field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HospitalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hospital.FieldHospitalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHospitalName(v)
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HospitalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HospitalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HospitalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HospitalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HospitalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HospitalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hospital nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HospitalMutation) ResetField(name string) error {
	switch name {
	case hospital.FieldHospitalName:
		m.ResetHospitalName()
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HospitalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hospital != nil {
		edges = append(edges, hospital.EdgeHospital)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HospitalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospital:
		ids := make([]ent.Value, 0, len(m.hospital))
		for id := range m.hospital {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HospitalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhospital != nil {
		edges = append(edges, hospital.EdgeHospital)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HospitalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospital:
		ids := make([]ent.Value, 0, len(m.removedhospital))
		for id := range m.removedhospital {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HospitalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhospital {
		edges = append(edges, hospital.EdgeHospital)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HospitalMutation) EdgeCleared(name string) bool {
	switch name {
	case hospital.EdgeHospital:
		return m.clearedhospital
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HospitalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HospitalMutation) ResetEdge(name string) error {
	switch name {
	case hospital.EdgeHospital:
		m.ResetHospital()
		return nil
	}
	return fmt.Errorf("unknown Hospital edge %s", name)
}

// MedicalProcedureMutation represents an operation that mutates the MedicalProcedure nodes in the graph.
type MedicalProcedureMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_Addtime              *time.Time
	clearedFields         map[string]struct{}
	_Patient              *int
	cleared_Patient       bool
	_ProcedureType        *int
	cleared_ProcedureType bool
	_Doctor               *int
	cleared_Doctor        bool
	done                  bool
	oldValue              func(context.Context) (*MedicalProcedure, error)
	predicates            []predicate.MedicalProcedure
}

var _ ent.Mutation = (*MedicalProcedureMutation)(nil)

// medicalprocedureOption allows management of the mutation configuration using functional options.
type medicalprocedureOption func(*MedicalProcedureMutation)

// newMedicalProcedureMutation creates new mutation for the MedicalProcedure entity.
func newMedicalProcedureMutation(c config, op Op, opts ...medicalprocedureOption) *MedicalProcedureMutation {
	m := &MedicalProcedureMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalProcedure,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalProcedureID sets the ID field of the mutation.
func withMedicalProcedureID(id int) medicalprocedureOption {
	return func(m *MedicalProcedureMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalProcedure
		)
		m.oldValue = func(ctx context.Context) (*MedicalProcedure, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalProcedure.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalProcedure sets the old MedicalProcedure of the mutation.
func withMedicalProcedure(node *MedicalProcedure) medicalprocedureOption {
	return func(m *MedicalProcedureMutation) {
		m.oldValue = func(context.Context) (*MedicalProcedure, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalProcedureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalProcedureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MedicalProcedureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddtime sets the "Addtime" field.
func (m *MedicalProcedureMutation) SetAddtime(t time.Time) {
	m._Addtime = &t
}

// Addtime returns the value of the "Addtime" field in the mutation.
func (m *MedicalProcedureMutation) Addtime() (r time.Time, exists bool) {
	v := m._Addtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddtime returns the old "Addtime" field's value of the MedicalProcedure entity.
// If the MedicalProcedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalProcedureMutation) OldAddtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddtime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddtime: %w", err)
	}
	return oldValue.Addtime, nil
}

// ResetAddtime resets all changes to the "Addtime" field.
func (m *MedicalProcedureMutation) ResetAddtime() {
	m._Addtime = nil
}

// SetPatientID sets the "Patient" edge to the Patient entity by id.
func (m *MedicalProcedureMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the "Patient" edge to the Patient entity.
func (m *MedicalProcedureMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the "Patient" edge to the Patient entity was cleared.
func (m *MedicalProcedureMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the "Patient" edge ID in the mutation.
func (m *MedicalProcedureMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the "Patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *MedicalProcedureMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "Patient" edge.
func (m *MedicalProcedureMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// SetProcedureTypeID sets the "ProcedureType" edge to the ProcedureType entity by id.
func (m *MedicalProcedureMutation) SetProcedureTypeID(id int) {
	m._ProcedureType = &id
}

// ClearProcedureType clears the "ProcedureType" edge to the ProcedureType entity.
func (m *MedicalProcedureMutation) ClearProcedureType() {
	m.cleared_ProcedureType = true
}

// ProcedureTypeCleared returns if the "ProcedureType" edge to the ProcedureType entity was cleared.
func (m *MedicalProcedureMutation) ProcedureTypeCleared() bool {
	return m.cleared_ProcedureType
}

// ProcedureTypeID returns the "ProcedureType" edge ID in the mutation.
func (m *MedicalProcedureMutation) ProcedureTypeID() (id int, exists bool) {
	if m._ProcedureType != nil {
		return *m._ProcedureType, true
	}
	return
}

// ProcedureTypeIDs returns the "ProcedureType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProcedureTypeID instead. It exists only for internal usage by the builders.
func (m *MedicalProcedureMutation) ProcedureTypeIDs() (ids []int) {
	if id := m._ProcedureType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProcedureType resets all changes to the "ProcedureType" edge.
func (m *MedicalProcedureMutation) ResetProcedureType() {
	m._ProcedureType = nil
	m.cleared_ProcedureType = false
}

// SetDoctorID sets the "Doctor" edge to the Doctor entity by id.
func (m *MedicalProcedureMutation) SetDoctorID(id int) {
	m._Doctor = &id
}

// ClearDoctor clears the "Doctor" edge to the Doctor entity.
func (m *MedicalProcedureMutation) ClearDoctor() {
	m.cleared_Doctor = true
}

// DoctorCleared returns if the "Doctor" edge to the Doctor entity was cleared.
func (m *MedicalProcedureMutation) DoctorCleared() bool {
	return m.cleared_Doctor
}

// DoctorID returns the "Doctor" edge ID in the mutation.
func (m *MedicalProcedureMutation) DoctorID() (id int, exists bool) {
	if m._Doctor != nil {
		return *m._Doctor, true
	}
	return
}

// DoctorIDs returns the "Doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *MedicalProcedureMutation) DoctorIDs() (ids []int) {
	if id := m._Doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor resets all changes to the "Doctor" edge.
func (m *MedicalProcedureMutation) ResetDoctor() {
	m._Doctor = nil
	m.cleared_Doctor = false
}

// Op returns the operation name.
func (m *MedicalProcedureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MedicalProcedure).
func (m *MedicalProcedureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalProcedureMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Addtime != nil {
		fields = append(fields, medicalprocedure.FieldAddtime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalProcedureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalprocedure.FieldAddtime:
		return m.Addtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalProcedureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalprocedure.FieldAddtime:
		return m.OldAddtime(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalProcedure field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalProcedureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalprocedure.FieldAddtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddtime(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalProcedureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalProcedureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalProcedureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MedicalProcedure numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalProcedureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalProcedureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalProcedureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicalProcedure nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalProcedureMutation) ResetField(name string) error {
	switch name {
	case medicalprocedure.FieldAddtime:
		m.ResetAddtime()
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalProcedureMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Patient != nil {
		edges = append(edges, medicalprocedure.EdgePatient)
	}
	if m._ProcedureType != nil {
		edges = append(edges, medicalprocedure.EdgeProcedureType)
	}
	if m._Doctor != nil {
		edges = append(edges, medicalprocedure.EdgeDoctor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalProcedureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicalprocedure.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	case medicalprocedure.EdgeProcedureType:
		if id := m._ProcedureType; id != nil {
			return []ent.Value{*id}
		}
	case medicalprocedure.EdgeDoctor:
		if id := m._Doctor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalProcedureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalProcedureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalProcedureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Patient {
		edges = append(edges, medicalprocedure.EdgePatient)
	}
	if m.cleared_ProcedureType {
		edges = append(edges, medicalprocedure.EdgeProcedureType)
	}
	if m.cleared_Doctor {
		edges = append(edges, medicalprocedure.EdgeDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalProcedureMutation) EdgeCleared(name string) bool {
	switch name {
	case medicalprocedure.EdgePatient:
		return m.cleared_Patient
	case medicalprocedure.EdgeProcedureType:
		return m.cleared_ProcedureType
	case medicalprocedure.EdgeDoctor:
		return m.cleared_Doctor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalProcedureMutation) ClearEdge(name string) error {
	switch name {
	case medicalprocedure.EdgePatient:
		m.ClearPatient()
		return nil
	case medicalprocedure.EdgeProcedureType:
		m.ClearProcedureType()
		return nil
	case medicalprocedure.EdgeDoctor:
		m.ClearDoctor()
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalProcedureMutation) ResetEdge(name string) error {
	switch name {
	case medicalprocedure.EdgePatient:
		m.ResetPatient()
		return nil
	case medicalprocedure.EdgeProcedureType:
		m.ResetProcedureType()
		return nil
	case medicalprocedure.EdgeDoctor:
		m.ResetDoctor()
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure edge %s", name)
}

// MedicalRecordMutation represents an operation that mutates the MedicalRecord nodes in the graph.
type MedicalRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	password      *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MedicalRecord, error)
	predicates    []predicate.MedicalRecord
}

var _ ent.Mutation = (*MedicalRecordMutation)(nil)

// medicalrecordOption allows management of the mutation configuration using functional options.
type medicalrecordOption func(*MedicalRecordMutation)

// newMedicalRecordMutation creates new mutation for the MedicalRecord entity.
func newMedicalRecordMutation(c config, op Op, opts ...medicalrecordOption) *MedicalRecordMutation {
	m := &MedicalRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalRecordID sets the ID field of the mutation.
func withMedicalRecordID(id int) medicalrecordOption {
	return func(m *MedicalRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalRecord
		)
		m.oldValue = func(ctx context.Context) (*MedicalRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalRecord sets the old MedicalRecord of the mutation.
func withMedicalRecord(node *MedicalRecord) medicalrecordOption {
	return func(m *MedicalRecordMutation) {
		m.oldValue = func(context.Context) (*MedicalRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MedicalRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *MedicalRecordMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MedicalRecordMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MedicalRecord entity.
// If the MedicalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalRecordMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MedicalRecordMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *MedicalRecordMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MedicalRecordMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the MedicalRecord entity.
// If the MedicalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalRecordMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MedicalRecordMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *MedicalRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MedicalRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MedicalRecord entity.
// If the MedicalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MedicalRecordMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *MedicalRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MedicalRecord).
func (m *MedicalRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalRecordMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, medicalrecord.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, medicalrecord.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, medicalrecord.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalrecord.FieldEmail:
		return m.Email()
	case medicalrecord.FieldPassword:
		return m.Password()
	case medicalrecord.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalrecord.FieldEmail:
		return m.OldEmail(ctx)
	case medicalrecord.FieldPassword:
		return m.OldPassword(ctx)
	case medicalrecord.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalrecord.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case medicalrecord.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case medicalrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MedicalRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicalRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalRecordMutation) ResetField(name string) error {
	switch name {
	case medicalrecord.FieldEmail:
		m.ResetEmail()
		return nil
	case medicalrecord.FieldPassword:
		m.ResetPassword()
		return nil
	case medicalrecord.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown MedicalRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MedicalRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MedicalRecord edge %s", name)
}

// NurseMutation represents an operation that mutates the Nurse nodes in the graph.
type NurseMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	nurseName                         *string
	nurseUsername                     *string
	nursePassword                     *string
	clearedFields                     map[string]struct{}
	triageResult                      map[int]struct{}
	removedtriageResult               map[int]struct{}
	clearedtriageResult               bool
	_NurseToAppointmentResults        map[int]struct{}
	removed_NurseToAppointmentResults map[int]struct{}
	cleared_NurseToAppointmentResults bool
	done                              bool
	oldValue                          func(context.Context) (*Nurse, error)
	predicates                        []predicate.Nurse
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows management of the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for the Nurse entity.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the ID field of the mutation.
func withNurseID(id int) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NurseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNurseName sets the "nurseName" field.
func (m *NurseMutation) SetNurseName(s string) {
	m.nurseName = &s
}

// NurseName returns the value of the "nurseName" field in the mutation.
func (m *NurseMutation) NurseName() (r string, exists bool) {
	v := m.nurseName
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseName returns the old "nurseName" field's value of the Nurse entity.
// If the Nurse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseMutation) OldNurseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseName: %w", err)
	}
	return oldValue.NurseName, nil
}

// ResetNurseName resets all changes to the "nurseName" field.
func (m *NurseMutation) ResetNurseName() {
	m.nurseName = nil
}

// SetNurseUsername sets the "nurseUsername" field.
func (m *NurseMutation) SetNurseUsername(s string) {
	m.nurseUsername = &s
}

// NurseUsername returns the value of the "nurseUsername" field in the mutation.
func (m *NurseMutation) NurseUsername() (r string, exists bool) {
	v := m.nurseUsername
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseUsername returns the old "nurseUsername" field's value of the Nurse entity.
// If the Nurse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseMutation) OldNurseUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseUsername: %w", err)
	}
	return oldValue.NurseUsername, nil
}

// ResetNurseUsername resets all changes to the "nurseUsername" field.
func (m *NurseMutation) ResetNurseUsername() {
	m.nurseUsername = nil
}

// SetNursePassword sets the "nursePassword" field.
func (m *NurseMutation) SetNursePassword(s string) {
	m.nursePassword = &s
}

// NursePassword returns the value of the "nursePassword" field in the mutation.
func (m *NurseMutation) NursePassword() (r string, exists bool) {
	v := m.nursePassword
	if v == nil {
		return
	}
	return *v, true
}

// OldNursePassword returns the old "nursePassword" field's value of the Nurse entity.
// If the Nurse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseMutation) OldNursePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNursePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNursePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNursePassword: %w", err)
	}
	return oldValue.NursePassword, nil
}

// ResetNursePassword resets all changes to the "nursePassword" field.
func (m *NurseMutation) ResetNursePassword() {
	m.nursePassword = nil
}

// AddTriageResultIDs adds the "triageResult" edge to the TriageResult entity by ids.
func (m *NurseMutation) AddTriageResultIDs(ids ...int) {
	if m.triageResult == nil {
		m.triageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.triageResult[ids[i]] = struct{}{}
	}
}

// ClearTriageResult clears the "triageResult" edge to the TriageResult entity.
func (m *NurseMutation) ClearTriageResult() {
	m.clearedtriageResult = true
}

// TriageResultCleared returns if the "triageResult" edge to the TriageResult entity was cleared.
func (m *NurseMutation) TriageResultCleared() bool {
	return m.clearedtriageResult
}

// RemoveTriageResultIDs removes the "triageResult" edge to the TriageResult entity by IDs.
func (m *NurseMutation) RemoveTriageResultIDs(ids ...int) {
	if m.removedtriageResult == nil {
		m.removedtriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtriageResult[ids[i]] = struct{}{}
	}
}

// RemovedTriageResult returns the removed IDs of the "triageResult" edge to the TriageResult entity.
func (m *NurseMutation) RemovedTriageResultIDs() (ids []int) {
	for id := range m.removedtriageResult {
		ids = append(ids, id)
	}
	return
}

// TriageResultIDs returns the "triageResult" edge IDs in the mutation.
func (m *NurseMutation) TriageResultIDs() (ids []int) {
	for id := range m.triageResult {
		ids = append(ids, id)
	}
	return
}

// ResetTriageResult resets all changes to the "triageResult" edge.
func (m *NurseMutation) ResetTriageResult() {
	m.triageResult = nil
	m.clearedtriageResult = false
	m.removedtriageResult = nil
}

// AddNurseToAppointmentResultIDs adds the "NurseToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *NurseMutation) AddNurseToAppointmentResultIDs(ids ...int) {
	if m._NurseToAppointmentResults == nil {
		m._NurseToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._NurseToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearNurseToAppointmentResults clears the "NurseToAppointmentResults" edge to the AppointmentResults entity.
func (m *NurseMutation) ClearNurseToAppointmentResults() {
	m.cleared_NurseToAppointmentResults = true
}

// NurseToAppointmentResultsCleared returns if the "NurseToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *NurseMutation) NurseToAppointmentResultsCleared() bool {
	return m.cleared_NurseToAppointmentResults
}

// RemoveNurseToAppointmentResultIDs removes the "NurseToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *NurseMutation) RemoveNurseToAppointmentResultIDs(ids ...int) {
	if m.removed_NurseToAppointmentResults == nil {
		m.removed_NurseToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_NurseToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedNurseToAppointmentResults returns the removed IDs of the "NurseToAppointmentResults" edge to the AppointmentResults entity.
func (m *NurseMutation) RemovedNurseToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_NurseToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// NurseToAppointmentResultsIDs returns the "NurseToAppointmentResults" edge IDs in the mutation.
func (m *NurseMutation) NurseToAppointmentResultsIDs() (ids []int) {
	for id := range m._NurseToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetNurseToAppointmentResults resets all changes to the "NurseToAppointmentResults" edge.
func (m *NurseMutation) ResetNurseToAppointmentResults() {
	m._NurseToAppointmentResults = nil
	m.cleared_NurseToAppointmentResults = false
	m.removed_NurseToAppointmentResults = nil
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.nurseName != nil {
		fields = append(fields, nurse.FieldNurseName)
	}
	if m.nurseUsername != nil {
		fields = append(fields, nurse.FieldNurseUsername)
	}
	if m.nursePassword != nil {
		fields = append(fields, nurse.FieldNursePassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldNurseName:
		return m.NurseName()
	case nurse.FieldNurseUsername:
		return m.NurseUsername()
	case nurse.FieldNursePassword:
		return m.NursePassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldNurseName:
		return m.OldNurseName(ctx)
	case nurse.FieldNurseUsername:
		return m.OldNurseUsername(ctx)
	case nurse.FieldNursePassword:
		return m.OldNursePassword(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldNurseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseName(v)
		return nil
	case nurse.FieldNurseUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseUsername(v)
		return nil
	case nurse.FieldNursePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNursePassword(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldNurseName:
		m.ResetNurseName()
		return nil
	case nurse.FieldNurseUsername:
		m.ResetNurseUsername()
		return nil
	case nurse.FieldNursePassword:
		m.ResetNursePassword()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.triageResult != nil {
		edges = append(edges, nurse.EdgeTriageResult)
	}
	if m._NurseToAppointmentResults != nil {
		edges = append(edges, nurse.EdgeNurseToAppointmentResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.triageResult))
		for id := range m.triageResult {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNurseToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._NurseToAppointmentResults))
		for id := range m._NurseToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtriageResult != nil {
		edges = append(edges, nurse.EdgeTriageResult)
	}
	if m.removed_NurseToAppointmentResults != nil {
		edges = append(edges, nurse.EdgeNurseToAppointmentResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.removedtriageResult))
		for id := range m.removedtriageResult {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNurseToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_NurseToAppointmentResults))
		for id := range m.removed_NurseToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtriageResult {
		edges = append(edges, nurse.EdgeTriageResult)
	}
	if m.cleared_NurseToAppointmentResults {
		edges = append(edges, nurse.EdgeNurseToAppointmentResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	case nurse.EdgeTriageResult:
		return m.clearedtriageResult
	case nurse.EdgeNurseToAppointmentResults:
		return m.cleared_NurseToAppointmentResults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeTriageResult:
		m.ResetTriageResult()
		return nil
	case nurse.EdgeNurseToAppointmentResults:
		m.ResetNurseToAppointmentResults()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	personalID                          *string
	hospitalNumber                      *string
	patientName                         *string
	drugAllergy                         *string
	mobileNumber                        *string
	added                               *time.Time
	clearedFields                       map[string]struct{}
	prefix                              *int
	clearedprefix                       bool
	gender                              *int
	clearedgender                       bool
	bloodtype                           *int
	clearedbloodtype                    bool
	triageResult                        map[int]struct{}
	removedtriageResult                 map[int]struct{}
	clearedtriageResult                 bool
	_PatientToAppointmentResults        map[int]struct{}
	removed_PatientToAppointmentResults map[int]struct{}
	cleared_PatientToAppointmentResults bool
	_PatientToMedicalProcedure          map[int]struct{}
	removed_PatientToMedicalProcedure   map[int]struct{}
	cleared_PatientToMedicalProcedure   bool
	_PatientToRightToTreatment          map[int]struct{}
	removed_PatientToRightToTreatment   map[int]struct{}
	cleared_PatientToRightToTreatment   bool
	_PatientToDiagnosis                 map[int]struct{}
	removed_PatientToDiagnosis          map[int]struct{}
	cleared_PatientToDiagnosis          bool
	done                                bool
	oldValue                            func(context.Context) (*Patient, error)
	predicates                          []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id int) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PatientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPersonalID sets the "personalID" field.
func (m *PatientMutation) SetPersonalID(s string) {
	m.personalID = &s
}

// PersonalID returns the value of the "personalID" field in the mutation.
func (m *PatientMutation) PersonalID() (r string, exists bool) {
	v := m.personalID
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalID returns the old "personalID" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPersonalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalID: %w", err)
	}
	return oldValue.PersonalID, nil
}

// ResetPersonalID resets all changes to the "personalID" field.
func (m *PatientMutation) ResetPersonalID() {
	m.personalID = nil
}

// SetHospitalNumber sets the "hospitalNumber" field.
func (m *PatientMutation) SetHospitalNumber(s string) {
	m.hospitalNumber = &s
}

// HospitalNumber returns the value of the "hospitalNumber" field in the mutation.
func (m *PatientMutation) HospitalNumber() (r string, exists bool) {
	v := m.hospitalNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldHospitalNumber returns the old "hospitalNumber" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldHospitalNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHospitalNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHospitalNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHospitalNumber: %w", err)
	}
	return oldValue.HospitalNumber, nil
}

// ResetHospitalNumber resets all changes to the "hospitalNumber" field.
func (m *PatientMutation) ResetHospitalNumber() {
	m.hospitalNumber = nil
}

// SetPatientName sets the "patientName" field.
func (m *PatientMutation) SetPatientName(s string) {
	m.patientName = &s
}

// PatientName returns the value of the "patientName" field in the mutation.
func (m *PatientMutation) PatientName() (r string, exists bool) {
	v := m.patientName
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientName returns the old "patientName" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientName: %w", err)
	}
	return oldValue.PatientName, nil
}

// ResetPatientName resets all changes to the "patientName" field.
func (m *PatientMutation) ResetPatientName() {
	m.patientName = nil
}

// SetDrugAllergy sets the "drugAllergy" field.
func (m *PatientMutation) SetDrugAllergy(s string) {
	m.drugAllergy = &s
}

// DrugAllergy returns the value of the "drugAllergy" field in the mutation.
func (m *PatientMutation) DrugAllergy() (r string, exists bool) {
	v := m.drugAllergy
	if v == nil {
		return
	}
	return *v, true
}

// OldDrugAllergy returns the old "drugAllergy" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldDrugAllergy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDrugAllergy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDrugAllergy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrugAllergy: %w", err)
	}
	return oldValue.DrugAllergy, nil
}

// ResetDrugAllergy resets all changes to the "drugAllergy" field.
func (m *PatientMutation) ResetDrugAllergy() {
	m.drugAllergy = nil
}

// SetMobileNumber sets the "mobileNumber" field.
func (m *PatientMutation) SetMobileNumber(s string) {
	m.mobileNumber = &s
}

// MobileNumber returns the value of the "mobileNumber" field in the mutation.
func (m *PatientMutation) MobileNumber() (r string, exists bool) {
	v := m.mobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "mobileNumber" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldMobileNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// ResetMobileNumber resets all changes to the "mobileNumber" field.
func (m *PatientMutation) ResetMobileNumber() {
	m.mobileNumber = nil
}

// SetAdded sets the "added" field.
func (m *PatientMutation) SetAdded(t time.Time) {
	m.added = &t
}

// Added returns the value of the "added" field in the mutation.
func (m *PatientMutation) Added() (r time.Time, exists bool) {
	v := m.added
	if v == nil {
		return
	}
	return *v, true
}

// OldAdded returns the old "added" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldAdded(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdded: %w", err)
	}
	return oldValue.Added, nil
}

// ResetAdded resets all changes to the "added" field.
func (m *PatientMutation) ResetAdded() {
	m.added = nil
}

// SetPrefixID sets the "prefix" edge to the Prefix entity by id.
func (m *PatientMutation) SetPrefixID(id int) {
	m.prefix = &id
}

// ClearPrefix clears the "prefix" edge to the Prefix entity.
func (m *PatientMutation) ClearPrefix() {
	m.clearedprefix = true
}

// PrefixCleared returns if the "prefix" edge to the Prefix entity was cleared.
func (m *PatientMutation) PrefixCleared() bool {
	return m.clearedprefix
}

// PrefixID returns the "prefix" edge ID in the mutation.
func (m *PatientMutation) PrefixID() (id int, exists bool) {
	if m.prefix != nil {
		return *m.prefix, true
	}
	return
}

// PrefixIDs returns the "prefix" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrefixID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) PrefixIDs() (ids []int) {
	if id := m.prefix; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrefix resets all changes to the "prefix" edge.
func (m *PatientMutation) ResetPrefix() {
	m.prefix = nil
	m.clearedprefix = false
}

// SetGenderID sets the "gender" edge to the Gender entity by id.
func (m *PatientMutation) SetGenderID(id int) {
	m.gender = &id
}

// ClearGender clears the "gender" edge to the Gender entity.
func (m *PatientMutation) ClearGender() {
	m.clearedgender = true
}

// GenderCleared returns if the "gender" edge to the Gender entity was cleared.
func (m *PatientMutation) GenderCleared() bool {
	return m.clearedgender
}

// GenderID returns the "gender" edge ID in the mutation.
func (m *PatientMutation) GenderID() (id int, exists bool) {
	if m.gender != nil {
		return *m.gender, true
	}
	return
}

// GenderIDs returns the "gender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenderID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) GenderIDs() (ids []int) {
	if id := m.gender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGender resets all changes to the "gender" edge.
func (m *PatientMutation) ResetGender() {
	m.gender = nil
	m.clearedgender = false
}

// SetBloodtypeID sets the "bloodtype" edge to the BloodType entity by id.
func (m *PatientMutation) SetBloodtypeID(id int) {
	m.bloodtype = &id
}

// ClearBloodtype clears the "bloodtype" edge to the BloodType entity.
func (m *PatientMutation) ClearBloodtype() {
	m.clearedbloodtype = true
}

// BloodtypeCleared returns if the "bloodtype" edge to the BloodType entity was cleared.
func (m *PatientMutation) BloodtypeCleared() bool {
	return m.clearedbloodtype
}

// BloodtypeID returns the "bloodtype" edge ID in the mutation.
func (m *PatientMutation) BloodtypeID() (id int, exists bool) {
	if m.bloodtype != nil {
		return *m.bloodtype, true
	}
	return
}

// BloodtypeIDs returns the "bloodtype" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BloodtypeID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) BloodtypeIDs() (ids []int) {
	if id := m.bloodtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBloodtype resets all changes to the "bloodtype" edge.
func (m *PatientMutation) ResetBloodtype() {
	m.bloodtype = nil
	m.clearedbloodtype = false
}

// AddTriageResultIDs adds the "triageResult" edge to the TriageResult entity by ids.
func (m *PatientMutation) AddTriageResultIDs(ids ...int) {
	if m.triageResult == nil {
		m.triageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.triageResult[ids[i]] = struct{}{}
	}
}

// ClearTriageResult clears the "triageResult" edge to the TriageResult entity.
func (m *PatientMutation) ClearTriageResult() {
	m.clearedtriageResult = true
}

// TriageResultCleared returns if the "triageResult" edge to the TriageResult entity was cleared.
func (m *PatientMutation) TriageResultCleared() bool {
	return m.clearedtriageResult
}

// RemoveTriageResultIDs removes the "triageResult" edge to the TriageResult entity by IDs.
func (m *PatientMutation) RemoveTriageResultIDs(ids ...int) {
	if m.removedtriageResult == nil {
		m.removedtriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtriageResult[ids[i]] = struct{}{}
	}
}

// RemovedTriageResult returns the removed IDs of the "triageResult" edge to the TriageResult entity.
func (m *PatientMutation) RemovedTriageResultIDs() (ids []int) {
	for id := range m.removedtriageResult {
		ids = append(ids, id)
	}
	return
}

// TriageResultIDs returns the "triageResult" edge IDs in the mutation.
func (m *PatientMutation) TriageResultIDs() (ids []int) {
	for id := range m.triageResult {
		ids = append(ids, id)
	}
	return
}

// ResetTriageResult resets all changes to the "triageResult" edge.
func (m *PatientMutation) ResetTriageResult() {
	m.triageResult = nil
	m.clearedtriageResult = false
	m.removedtriageResult = nil
}

// AddPatientToAppointmentResultIDs adds the "PatientToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *PatientMutation) AddPatientToAppointmentResultIDs(ids ...int) {
	if m._PatientToAppointmentResults == nil {
		m._PatientToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearPatientToAppointmentResults clears the "PatientToAppointmentResults" edge to the AppointmentResults entity.
func (m *PatientMutation) ClearPatientToAppointmentResults() {
	m.cleared_PatientToAppointmentResults = true
}

// PatientToAppointmentResultsCleared returns if the "PatientToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *PatientMutation) PatientToAppointmentResultsCleared() bool {
	return m.cleared_PatientToAppointmentResults
}

// RemovePatientToAppointmentResultIDs removes the "PatientToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *PatientMutation) RemovePatientToAppointmentResultIDs(ids ...int) {
	if m.removed_PatientToAppointmentResults == nil {
		m.removed_PatientToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedPatientToAppointmentResults returns the removed IDs of the "PatientToAppointmentResults" edge to the AppointmentResults entity.
func (m *PatientMutation) RemovedPatientToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_PatientToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// PatientToAppointmentResultsIDs returns the "PatientToAppointmentResults" edge IDs in the mutation.
func (m *PatientMutation) PatientToAppointmentResultsIDs() (ids []int) {
	for id := range m._PatientToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToAppointmentResults resets all changes to the "PatientToAppointmentResults" edge.
func (m *PatientMutation) ResetPatientToAppointmentResults() {
	m._PatientToAppointmentResults = nil
	m.cleared_PatientToAppointmentResults = false
	m.removed_PatientToAppointmentResults = nil
}

// AddPatientToMedicalProcedureIDs adds the "PatientToMedicalProcedure" edge to the MedicalProcedure entity by ids.
func (m *PatientMutation) AddPatientToMedicalProcedureIDs(ids ...int) {
	if m._PatientToMedicalProcedure == nil {
		m._PatientToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// ClearPatientToMedicalProcedure clears the "PatientToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *PatientMutation) ClearPatientToMedicalProcedure() {
	m.cleared_PatientToMedicalProcedure = true
}

// PatientToMedicalProcedureCleared returns if the "PatientToMedicalProcedure" edge to the MedicalProcedure entity was cleared.
func (m *PatientMutation) PatientToMedicalProcedureCleared() bool {
	return m.cleared_PatientToMedicalProcedure
}

// RemovePatientToMedicalProcedureIDs removes the "PatientToMedicalProcedure" edge to the MedicalProcedure entity by IDs.
func (m *PatientMutation) RemovePatientToMedicalProcedureIDs(ids ...int) {
	if m.removed_PatientToMedicalProcedure == nil {
		m.removed_PatientToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// RemovedPatientToMedicalProcedure returns the removed IDs of the "PatientToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *PatientMutation) RemovedPatientToMedicalProcedureIDs() (ids []int) {
	for id := range m.removed_PatientToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// PatientToMedicalProcedureIDs returns the "PatientToMedicalProcedure" edge IDs in the mutation.
func (m *PatientMutation) PatientToMedicalProcedureIDs() (ids []int) {
	for id := range m._PatientToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToMedicalProcedure resets all changes to the "PatientToMedicalProcedure" edge.
func (m *PatientMutation) ResetPatientToMedicalProcedure() {
	m._PatientToMedicalProcedure = nil
	m.cleared_PatientToMedicalProcedure = false
	m.removed_PatientToMedicalProcedure = nil
}

// AddPatientToRightToTreatmentIDs adds the "PatientToRightToTreatment" edge to the RightToTreatment entity by ids.
func (m *PatientMutation) AddPatientToRightToTreatmentIDs(ids ...int) {
	if m._PatientToRightToTreatment == nil {
		m._PatientToRightToTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToRightToTreatment[ids[i]] = struct{}{}
	}
}

// ClearPatientToRightToTreatment clears the "PatientToRightToTreatment" edge to the RightToTreatment entity.
func (m *PatientMutation) ClearPatientToRightToTreatment() {
	m.cleared_PatientToRightToTreatment = true
}

// PatientToRightToTreatmentCleared returns if the "PatientToRightToTreatment" edge to the RightToTreatment entity was cleared.
func (m *PatientMutation) PatientToRightToTreatmentCleared() bool {
	return m.cleared_PatientToRightToTreatment
}

// RemovePatientToRightToTreatmentIDs removes the "PatientToRightToTreatment" edge to the RightToTreatment entity by IDs.
func (m *PatientMutation) RemovePatientToRightToTreatmentIDs(ids ...int) {
	if m.removed_PatientToRightToTreatment == nil {
		m.removed_PatientToRightToTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToRightToTreatment[ids[i]] = struct{}{}
	}
}

// RemovedPatientToRightToTreatment returns the removed IDs of the "PatientToRightToTreatment" edge to the RightToTreatment entity.
func (m *PatientMutation) RemovedPatientToRightToTreatmentIDs() (ids []int) {
	for id := range m.removed_PatientToRightToTreatment {
		ids = append(ids, id)
	}
	return
}

// PatientToRightToTreatmentIDs returns the "PatientToRightToTreatment" edge IDs in the mutation.
func (m *PatientMutation) PatientToRightToTreatmentIDs() (ids []int) {
	for id := range m._PatientToRightToTreatment {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToRightToTreatment resets all changes to the "PatientToRightToTreatment" edge.
func (m *PatientMutation) ResetPatientToRightToTreatment() {
	m._PatientToRightToTreatment = nil
	m.cleared_PatientToRightToTreatment = false
	m.removed_PatientToRightToTreatment = nil
}

// AddPatientToDiagnosiIDs adds the "PatientToDiagnosis" edge to the Diagnosis entity by ids.
func (m *PatientMutation) AddPatientToDiagnosiIDs(ids ...int) {
	if m._PatientToDiagnosis == nil {
		m._PatientToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToDiagnosis[ids[i]] = struct{}{}
	}
}

// ClearPatientToDiagnosis clears the "PatientToDiagnosis" edge to the Diagnosis entity.
func (m *PatientMutation) ClearPatientToDiagnosis() {
	m.cleared_PatientToDiagnosis = true
}

// PatientToDiagnosisCleared returns if the "PatientToDiagnosis" edge to the Diagnosis entity was cleared.
func (m *PatientMutation) PatientToDiagnosisCleared() bool {
	return m.cleared_PatientToDiagnosis
}

// RemovePatientToDiagnosiIDs removes the "PatientToDiagnosis" edge to the Diagnosis entity by IDs.
func (m *PatientMutation) RemovePatientToDiagnosiIDs(ids ...int) {
	if m.removed_PatientToDiagnosis == nil {
		m.removed_PatientToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToDiagnosis[ids[i]] = struct{}{}
	}
}

// RemovedPatientToDiagnosis returns the removed IDs of the "PatientToDiagnosis" edge to the Diagnosis entity.
func (m *PatientMutation) RemovedPatientToDiagnosisIDs() (ids []int) {
	for id := range m.removed_PatientToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// PatientToDiagnosisIDs returns the "PatientToDiagnosis" edge IDs in the mutation.
func (m *PatientMutation) PatientToDiagnosisIDs() (ids []int) {
	for id := range m._PatientToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToDiagnosis resets all changes to the "PatientToDiagnosis" edge.
func (m *PatientMutation) ResetPatientToDiagnosis() {
	m._PatientToDiagnosis = nil
	m.cleared_PatientToDiagnosis = false
	m.removed_PatientToDiagnosis = nil
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.personalID != nil {
		fields = append(fields, patient.FieldPersonalID)
	}
	if m.hospitalNumber != nil {
		fields = append(fields, patient.FieldHospitalNumber)
	}
	if m.patientName != nil {
		fields = append(fields, patient.FieldPatientName)
	}
	if m.drugAllergy != nil {
		fields = append(fields, patient.FieldDrugAllergy)
	}
	if m.mobileNumber != nil {
		fields = append(fields, patient.FieldMobileNumber)
	}
	if m.added != nil {
		fields = append(fields, patient.FieldAdded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPersonalID:
		return m.PersonalID()
	case patient.FieldHospitalNumber:
		return m.HospitalNumber()
	case patient.FieldPatientName:
		return m.PatientName()
	case patient.FieldDrugAllergy:
		return m.DrugAllergy()
	case patient.FieldMobileNumber:
		return m.MobileNumber()
	case patient.FieldAdded:
		return m.Added()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldPersonalID:
		return m.OldPersonalID(ctx)
	case patient.FieldHospitalNumber:
		return m.OldHospitalNumber(ctx)
	case patient.FieldPatientName:
		return m.OldPatientName(ctx)
	case patient.FieldDrugAllergy:
		return m.OldDrugAllergy(ctx)
	case patient.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case patient.FieldAdded:
		return m.OldAdded(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPersonalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalID(v)
		return nil
	case patient.FieldHospitalNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHospitalNumber(v)
		return nil
	case patient.FieldPatientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientName(v)
		return nil
	case patient.FieldDrugAllergy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrugAllergy(v)
		return nil
	case patient.FieldMobileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case patient.FieldAdded:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdded(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldPersonalID:
		m.ResetPersonalID()
		return nil
	case patient.FieldHospitalNumber:
		m.ResetHospitalNumber()
		return nil
	case patient.FieldPatientName:
		m.ResetPatientName()
		return nil
	case patient.FieldDrugAllergy:
		m.ResetDrugAllergy()
		return nil
	case patient.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case patient.FieldAdded:
		m.ResetAdded()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.prefix != nil {
		edges = append(edges, patient.EdgePrefix)
	}
	if m.gender != nil {
		edges = append(edges, patient.EdgeGender)
	}
	if m.bloodtype != nil {
		edges = append(edges, patient.EdgeBloodtype)
	}
	if m.triageResult != nil {
		edges = append(edges, patient.EdgeTriageResult)
	}
	if m._PatientToAppointmentResults != nil {
		edges = append(edges, patient.EdgePatientToAppointmentResults)
	}
	if m._PatientToMedicalProcedure != nil {
		edges = append(edges, patient.EdgePatientToMedicalProcedure)
	}
	if m._PatientToRightToTreatment != nil {
		edges = append(edges, patient.EdgePatientToRightToTreatment)
	}
	if m._PatientToDiagnosis != nil {
		edges = append(edges, patient.EdgePatientToDiagnosis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePrefix:
		if id := m.prefix; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeGender:
		if id := m.gender; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeBloodtype:
		if id := m.bloodtype; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.triageResult))
		for id := range m.triageResult {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._PatientToAppointmentResults))
		for id := range m._PatientToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m._PatientToMedicalProcedure))
		for id := range m._PatientToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToRightToTreatment:
		ids := make([]ent.Value, 0, len(m._PatientToRightToTreatment))
		for id := range m._PatientToRightToTreatment {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToDiagnosis:
		ids := make([]ent.Value, 0, len(m._PatientToDiagnosis))
		for id := range m._PatientToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedtriageResult != nil {
		edges = append(edges, patient.EdgeTriageResult)
	}
	if m.removed_PatientToAppointmentResults != nil {
		edges = append(edges, patient.EdgePatientToAppointmentResults)
	}
	if m.removed_PatientToMedicalProcedure != nil {
		edges = append(edges, patient.EdgePatientToMedicalProcedure)
	}
	if m.removed_PatientToRightToTreatment != nil {
		edges = append(edges, patient.EdgePatientToRightToTreatment)
	}
	if m.removed_PatientToDiagnosis != nil {
		edges = append(edges, patient.EdgePatientToDiagnosis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.removedtriageResult))
		for id := range m.removedtriageResult {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_PatientToAppointmentResults))
		for id := range m.removed_PatientToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m.removed_PatientToMedicalProcedure))
		for id := range m.removed_PatientToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToRightToTreatment:
		ids := make([]ent.Value, 0, len(m.removed_PatientToRightToTreatment))
		for id := range m.removed_PatientToRightToTreatment {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToDiagnosis:
		ids := make([]ent.Value, 0, len(m.removed_PatientToDiagnosis))
		for id := range m.removed_PatientToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedprefix {
		edges = append(edges, patient.EdgePrefix)
	}
	if m.clearedgender {
		edges = append(edges, patient.EdgeGender)
	}
	if m.clearedbloodtype {
		edges = append(edges, patient.EdgeBloodtype)
	}
	if m.clearedtriageResult {
		edges = append(edges, patient.EdgeTriageResult)
	}
	if m.cleared_PatientToAppointmentResults {
		edges = append(edges, patient.EdgePatientToAppointmentResults)
	}
	if m.cleared_PatientToMedicalProcedure {
		edges = append(edges, patient.EdgePatientToMedicalProcedure)
	}
	if m.cleared_PatientToRightToTreatment {
		edges = append(edges, patient.EdgePatientToRightToTreatment)
	}
	if m.cleared_PatientToDiagnosis {
		edges = append(edges, patient.EdgePatientToDiagnosis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgePrefix:
		return m.clearedprefix
	case patient.EdgeGender:
		return m.clearedgender
	case patient.EdgeBloodtype:
		return m.clearedbloodtype
	case patient.EdgeTriageResult:
		return m.clearedtriageResult
	case patient.EdgePatientToAppointmentResults:
		return m.cleared_PatientToAppointmentResults
	case patient.EdgePatientToMedicalProcedure:
		return m.cleared_PatientToMedicalProcedure
	case patient.EdgePatientToRightToTreatment:
		return m.cleared_PatientToRightToTreatment
	case patient.EdgePatientToDiagnosis:
		return m.cleared_PatientToDiagnosis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	case patient.EdgePrefix:
		m.ClearPrefix()
		return nil
	case patient.EdgeGender:
		m.ClearGender()
		return nil
	case patient.EdgeBloodtype:
		m.ClearBloodtype()
		return nil
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgePrefix:
		m.ResetPrefix()
		return nil
	case patient.EdgeGender:
		m.ResetGender()
		return nil
	case patient.EdgeBloodtype:
		m.ResetBloodtype()
		return nil
	case patient.EdgeTriageResult:
		m.ResetTriageResult()
		return nil
	case patient.EdgePatientToAppointmentResults:
		m.ResetPatientToAppointmentResults()
		return nil
	case patient.EdgePatientToMedicalProcedure:
		m.ResetPatientToMedicalProcedure()
		return nil
	case patient.EdgePatientToRightToTreatment:
		m.ResetPatientToRightToTreatment()
		return nil
	case patient.EdgePatientToDiagnosis:
		m.ResetPatientToDiagnosis()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PrefixMutation represents an operation that mutates the Prefix nodes in the graph.
type PrefixMutation struct {
	config
	op              Op
	typ             string
	id              *int
	prefixValue     *string
	clearedFields   map[string]struct{}
	patients        map[int]struct{}
	removedpatients map[int]struct{}
	clearedpatients bool
	done            bool
	oldValue        func(context.Context) (*Prefix, error)
	predicates      []predicate.Prefix
}

var _ ent.Mutation = (*PrefixMutation)(nil)

// prefixOption allows management of the mutation configuration using functional options.
type prefixOption func(*PrefixMutation)

// newPrefixMutation creates new mutation for the Prefix entity.
func newPrefixMutation(c config, op Op, opts ...prefixOption) *PrefixMutation {
	m := &PrefixMutation{
		config:        c,
		op:            op,
		typ:           TypePrefix,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrefixID sets the ID field of the mutation.
func withPrefixID(id int) prefixOption {
	return func(m *PrefixMutation) {
		var (
			err   error
			once  sync.Once
			value *Prefix
		)
		m.oldValue = func(ctx context.Context) (*Prefix, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prefix.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrefix sets the old Prefix of the mutation.
func withPrefix(node *Prefix) prefixOption {
	return func(m *PrefixMutation) {
		m.oldValue = func(context.Context) (*Prefix, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrefixMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrefixMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PrefixMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrefixValue sets the "prefixValue" field.
func (m *PrefixMutation) SetPrefixValue(s string) {
	m.prefixValue = &s
}

// PrefixValue returns the value of the "prefixValue" field in the mutation.
func (m *PrefixMutation) PrefixValue() (r string, exists bool) {
	v := m.prefixValue
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefixValue returns the old "prefixValue" field's value of the Prefix entity.
// If the Prefix object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrefixMutation) OldPrefixValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrefixValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrefixValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefixValue: %w", err)
	}
	return oldValue.PrefixValue, nil
}

// ResetPrefixValue resets all changes to the "prefixValue" field.
func (m *PrefixMutation) ResetPrefixValue() {
	m.prefixValue = nil
}

// AddPatientIDs adds the "patients" edge to the Patient entity by ids.
func (m *PrefixMutation) AddPatientIDs(ids ...int) {
	if m.patients == nil {
		m.patients = make(map[int]struct{})
	}
	for i := range ids {
		m.patients[ids[i]] = struct{}{}
	}
}

// ClearPatients clears the "patients" edge to the Patient entity.
func (m *PrefixMutation) ClearPatients() {
	m.clearedpatients = true
}

// PatientsCleared returns if the "patients" edge to the Patient entity was cleared.
func (m *PrefixMutation) PatientsCleared() bool {
	return m.clearedpatients
}

// RemovePatientIDs removes the "patients" edge to the Patient entity by IDs.
func (m *PrefixMutation) RemovePatientIDs(ids ...int) {
	if m.removedpatients == nil {
		m.removedpatients = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatients[ids[i]] = struct{}{}
	}
}

// RemovedPatients returns the removed IDs of the "patients" edge to the Patient entity.
func (m *PrefixMutation) RemovedPatientsIDs() (ids []int) {
	for id := range m.removedpatients {
		ids = append(ids, id)
	}
	return
}

// PatientsIDs returns the "patients" edge IDs in the mutation.
func (m *PrefixMutation) PatientsIDs() (ids []int) {
	for id := range m.patients {
		ids = append(ids, id)
	}
	return
}

// ResetPatients resets all changes to the "patients" edge.
func (m *PrefixMutation) ResetPatients() {
	m.patients = nil
	m.clearedpatients = false
	m.removedpatients = nil
}

// Op returns the operation name.
func (m *PrefixMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prefix).
func (m *PrefixMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrefixMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.prefixValue != nil {
		fields = append(fields, prefix.FieldPrefixValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrefixMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prefix.FieldPrefixValue:
		return m.PrefixValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrefixMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prefix.FieldPrefixValue:
		return m.OldPrefixValue(ctx)
	}
	return nil, fmt.Errorf("unknown Prefix field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrefixMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prefix.FieldPrefixValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefixValue(v)
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrefixMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrefixMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrefixMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrefixMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrefixMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrefixMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prefix nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrefixMutation) ResetField(name string) error {
	switch name {
	case prefix.FieldPrefixValue:
		m.ResetPrefixValue()
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrefixMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.patients != nil {
		edges = append(edges, prefix.EdgePatients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrefixMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePatients:
		ids := make([]ent.Value, 0, len(m.patients))
		for id := range m.patients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrefixMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpatients != nil {
		edges = append(edges, prefix.EdgePatients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrefixMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePatients:
		ids := make([]ent.Value, 0, len(m.removedpatients))
		for id := range m.removedpatients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrefixMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpatients {
		edges = append(edges, prefix.EdgePatients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrefixMutation) EdgeCleared(name string) bool {
	switch name {
	case prefix.EdgePatients:
		return m.clearedpatients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrefixMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrefixMutation) ResetEdge(name string) error {
	switch name {
	case prefix.EdgePatients:
		m.ResetPatients()
		return nil
	}
	return fmt.Errorf("unknown Prefix edge %s", name)
}

// ProcedureTypeMutation represents an operation that mutates the ProcedureType nodes in the graph.
type ProcedureTypeMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	_ProcedureName                      *string
	clearedFields                       map[string]struct{}
	_ProcedureToMedicalProcedure        map[int]struct{}
	removed_ProcedureToMedicalProcedure map[int]struct{}
	cleared_ProcedureToMedicalProcedure bool
	done                                bool
	oldValue                            func(context.Context) (*ProcedureType, error)
	predicates                          []predicate.ProcedureType
}

var _ ent.Mutation = (*ProcedureTypeMutation)(nil)

// proceduretypeOption allows management of the mutation configuration using functional options.
type proceduretypeOption func(*ProcedureTypeMutation)

// newProcedureTypeMutation creates new mutation for the ProcedureType entity.
func newProcedureTypeMutation(c config, op Op, opts ...proceduretypeOption) *ProcedureTypeMutation {
	m := &ProcedureTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProcedureType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcedureTypeID sets the ID field of the mutation.
func withProcedureTypeID(id int) proceduretypeOption {
	return func(m *ProcedureTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcedureType
		)
		m.oldValue = func(ctx context.Context) (*ProcedureType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcedureType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcedureType sets the old ProcedureType of the mutation.
func withProcedureType(node *ProcedureType) proceduretypeOption {
	return func(m *ProcedureTypeMutation) {
		m.oldValue = func(context.Context) (*ProcedureType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcedureTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcedureTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProcedureTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProcedureName sets the "ProcedureName" field.
func (m *ProcedureTypeMutation) SetProcedureName(s string) {
	m._ProcedureName = &s
}

// ProcedureName returns the value of the "ProcedureName" field in the mutation.
func (m *ProcedureTypeMutation) ProcedureName() (r string, exists bool) {
	v := m._ProcedureName
	if v == nil {
		return
	}
	return *v, true
}

// OldProcedureName returns the old "ProcedureName" field's value of the ProcedureType entity.
// If the ProcedureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureTypeMutation) OldProcedureName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProcedureName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProcedureName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcedureName: %w", err)
	}
	return oldValue.ProcedureName, nil
}

// ResetProcedureName resets all changes to the "ProcedureName" field.
func (m *ProcedureTypeMutation) ResetProcedureName() {
	m._ProcedureName = nil
}

// AddProcedureToMedicalProcedureIDs adds the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity by ids.
func (m *ProcedureTypeMutation) AddProcedureToMedicalProcedureIDs(ids ...int) {
	if m._ProcedureToMedicalProcedure == nil {
		m._ProcedureToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m._ProcedureToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// ClearProcedureToMedicalProcedure clears the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *ProcedureTypeMutation) ClearProcedureToMedicalProcedure() {
	m.cleared_ProcedureToMedicalProcedure = true
}

// ProcedureToMedicalProcedureCleared returns if the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity was cleared.
func (m *ProcedureTypeMutation) ProcedureToMedicalProcedureCleared() bool {
	return m.cleared_ProcedureToMedicalProcedure
}

// RemoveProcedureToMedicalProcedureIDs removes the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity by IDs.
func (m *ProcedureTypeMutation) RemoveProcedureToMedicalProcedureIDs(ids ...int) {
	if m.removed_ProcedureToMedicalProcedure == nil {
		m.removed_ProcedureToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProcedureToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// RemovedProcedureToMedicalProcedure returns the removed IDs of the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *ProcedureTypeMutation) RemovedProcedureToMedicalProcedureIDs() (ids []int) {
	for id := range m.removed_ProcedureToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ProcedureToMedicalProcedureIDs returns the "ProcedureToMedicalProcedure" edge IDs in the mutation.
func (m *ProcedureTypeMutation) ProcedureToMedicalProcedureIDs() (ids []int) {
	for id := range m._ProcedureToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ResetProcedureToMedicalProcedure resets all changes to the "ProcedureToMedicalProcedure" edge.
func (m *ProcedureTypeMutation) ResetProcedureToMedicalProcedure() {
	m._ProcedureToMedicalProcedure = nil
	m.cleared_ProcedureToMedicalProcedure = false
	m.removed_ProcedureToMedicalProcedure = nil
}

// Op returns the operation name.
func (m *ProcedureTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProcedureType).
func (m *ProcedureTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcedureTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ProcedureName != nil {
		fields = append(fields, proceduretype.FieldProcedureName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcedureTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proceduretype.FieldProcedureName:
		return m.ProcedureName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcedureTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proceduretype.FieldProcedureName:
		return m.OldProcedureName(ctx)
	}
	return nil, fmt.Errorf("unknown ProcedureType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proceduretype.FieldProcedureName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcedureName(v)
		return nil
	}
	return fmt.Errorf("unknown ProcedureType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcedureTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcedureTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProcedureType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcedureTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcedureTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcedureTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProcedureType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcedureTypeMutation) ResetField(name string) error {
	switch name {
	case proceduretype.FieldProcedureName:
		m.ResetProcedureName()
		return nil
	}
	return fmt.Errorf("unknown ProcedureType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcedureTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ProcedureToMedicalProcedure != nil {
		edges = append(edges, proceduretype.EdgeProcedureToMedicalProcedure)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcedureTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m._ProcedureToMedicalProcedure))
		for id := range m._ProcedureToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcedureTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_ProcedureToMedicalProcedure != nil {
		edges = append(edges, proceduretype.EdgeProcedureToMedicalProcedure)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcedureTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m.removed_ProcedureToMedicalProcedure))
		for id := range m.removed_ProcedureToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcedureTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ProcedureToMedicalProcedure {
		edges = append(edges, proceduretype.EdgeProcedureToMedicalProcedure)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcedureTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		return m.cleared_ProcedureToMedicalProcedure
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcedureTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProcedureType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcedureTypeMutation) ResetEdge(name string) error {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		m.ResetProcedureToMedicalProcedure()
		return nil
	}
	return fmt.Errorf("unknown ProcedureType edge %s", name)
}

// RightToTreatmentMutation represents an operation that mutates the RightToTreatment nodes in the graph.
type RightToTreatmentMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_StartTime                   *time.Time
	_EndTime                     *time.Time
	clearedFields                map[string]struct{}
	_Hospital                    *int
	cleared_Hospital             bool
	_RightToTreatmentType        *int
	cleared_RightToTreatmentType bool
	_Patient                     *int
	cleared_Patient              bool
	done                         bool
	oldValue                     func(context.Context) (*RightToTreatment, error)
	predicates                   []predicate.RightToTreatment
}

var _ ent.Mutation = (*RightToTreatmentMutation)(nil)

// righttotreatmentOption allows management of the mutation configuration using functional options.
type righttotreatmentOption func(*RightToTreatmentMutation)

// newRightToTreatmentMutation creates new mutation for the RightToTreatment entity.
func newRightToTreatmentMutation(c config, op Op, opts ...righttotreatmentOption) *RightToTreatmentMutation {
	m := &RightToTreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeRightToTreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRightToTreatmentID sets the ID field of the mutation.
func withRightToTreatmentID(id int) righttotreatmentOption {
	return func(m *RightToTreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *RightToTreatment
		)
		m.oldValue = func(ctx context.Context) (*RightToTreatment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RightToTreatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRightToTreatment sets the old RightToTreatment of the mutation.
func withRightToTreatment(node *RightToTreatment) righttotreatmentOption {
	return func(m *RightToTreatmentMutation) {
		m.oldValue = func(context.Context) (*RightToTreatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RightToTreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RightToTreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RightToTreatmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStartTime sets the "StartTime" field.
func (m *RightToTreatmentMutation) SetStartTime(t time.Time) {
	m._StartTime = &t
}

// StartTime returns the value of the "StartTime" field in the mutation.
func (m *RightToTreatmentMutation) StartTime() (r time.Time, exists bool) {
	v := m._StartTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "StartTime" field's value of the RightToTreatment entity.
// If the RightToTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RightToTreatmentMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "StartTime" field.
func (m *RightToTreatmentMutation) ResetStartTime() {
	m._StartTime = nil
}

// SetEndTime sets the "EndTime" field.
func (m *RightToTreatmentMutation) SetEndTime(t time.Time) {
	m._EndTime = &t
}

// EndTime returns the value of the "EndTime" field in the mutation.
func (m *RightToTreatmentMutation) EndTime() (r time.Time, exists bool) {
	v := m._EndTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "EndTime" field's value of the RightToTreatment entity.
// If the RightToTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RightToTreatmentMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "EndTime" field.
func (m *RightToTreatmentMutation) ResetEndTime() {
	m._EndTime = nil
}

// SetHospitalID sets the "Hospital" edge to the Hospital entity by id.
func (m *RightToTreatmentMutation) SetHospitalID(id int) {
	m._Hospital = &id
}

// ClearHospital clears the "Hospital" edge to the Hospital entity.
func (m *RightToTreatmentMutation) ClearHospital() {
	m.cleared_Hospital = true
}

// HospitalCleared returns if the "Hospital" edge to the Hospital entity was cleared.
func (m *RightToTreatmentMutation) HospitalCleared() bool {
	return m.cleared_Hospital
}

// HospitalID returns the "Hospital" edge ID in the mutation.
func (m *RightToTreatmentMutation) HospitalID() (id int, exists bool) {
	if m._Hospital != nil {
		return *m._Hospital, true
	}
	return
}

// HospitalIDs returns the "Hospital" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HospitalID instead. It exists only for internal usage by the builders.
func (m *RightToTreatmentMutation) HospitalIDs() (ids []int) {
	if id := m._Hospital; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHospital resets all changes to the "Hospital" edge.
func (m *RightToTreatmentMutation) ResetHospital() {
	m._Hospital = nil
	m.cleared_Hospital = false
}

// SetRightToTreatmentTypeID sets the "RightToTreatmentType" edge to the RightToTreatmentType entity by id.
func (m *RightToTreatmentMutation) SetRightToTreatmentTypeID(id int) {
	m._RightToTreatmentType = &id
}

// ClearRightToTreatmentType clears the "RightToTreatmentType" edge to the RightToTreatmentType entity.
func (m *RightToTreatmentMutation) ClearRightToTreatmentType() {
	m.cleared_RightToTreatmentType = true
}

// RightToTreatmentTypeCleared returns if the "RightToTreatmentType" edge to the RightToTreatmentType entity was cleared.
func (m *RightToTreatmentMutation) RightToTreatmentTypeCleared() bool {
	return m.cleared_RightToTreatmentType
}

// RightToTreatmentTypeID returns the "RightToTreatmentType" edge ID in the mutation.
func (m *RightToTreatmentMutation) RightToTreatmentTypeID() (id int, exists bool) {
	if m._RightToTreatmentType != nil {
		return *m._RightToTreatmentType, true
	}
	return
}

// RightToTreatmentTypeIDs returns the "RightToTreatmentType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RightToTreatmentTypeID instead. It exists only for internal usage by the builders.
func (m *RightToTreatmentMutation) RightToTreatmentTypeIDs() (ids []int) {
	if id := m._RightToTreatmentType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRightToTreatmentType resets all changes to the "RightToTreatmentType" edge.
func (m *RightToTreatmentMutation) ResetRightToTreatmentType() {
	m._RightToTreatmentType = nil
	m.cleared_RightToTreatmentType = false
}

// SetPatientID sets the "Patient" edge to the Patient entity by id.
func (m *RightToTreatmentMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the "Patient" edge to the Patient entity.
func (m *RightToTreatmentMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the "Patient" edge to the Patient entity was cleared.
func (m *RightToTreatmentMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the "Patient" edge ID in the mutation.
func (m *RightToTreatmentMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the "Patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *RightToTreatmentMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "Patient" edge.
func (m *RightToTreatmentMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// Op returns the operation name.
func (m *RightToTreatmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RightToTreatment).
func (m *RightToTreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RightToTreatmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._StartTime != nil {
		fields = append(fields, righttotreatment.FieldStartTime)
	}
	if m._EndTime != nil {
		fields = append(fields, righttotreatment.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RightToTreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case righttotreatment.FieldStartTime:
		return m.StartTime()
	case righttotreatment.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RightToTreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case righttotreatment.FieldStartTime:
		return m.OldStartTime(ctx)
	case righttotreatment.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown RightToTreatment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case righttotreatment.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case righttotreatment.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RightToTreatmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RightToTreatmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RightToTreatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RightToTreatmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RightToTreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RightToTreatmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RightToTreatment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RightToTreatmentMutation) ResetField(name string) error {
	switch name {
	case righttotreatment.FieldStartTime:
		m.ResetStartTime()
		return nil
	case righttotreatment.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RightToTreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Hospital != nil {
		edges = append(edges, righttotreatment.EdgeHospital)
	}
	if m._RightToTreatmentType != nil {
		edges = append(edges, righttotreatment.EdgeRightToTreatmentType)
	}
	if m._Patient != nil {
		edges = append(edges, righttotreatment.EdgePatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RightToTreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case righttotreatment.EdgeHospital:
		if id := m._Hospital; id != nil {
			return []ent.Value{*id}
		}
	case righttotreatment.EdgeRightToTreatmentType:
		if id := m._RightToTreatmentType; id != nil {
			return []ent.Value{*id}
		}
	case righttotreatment.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RightToTreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RightToTreatmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RightToTreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Hospital {
		edges = append(edges, righttotreatment.EdgeHospital)
	}
	if m.cleared_RightToTreatmentType {
		edges = append(edges, righttotreatment.EdgeRightToTreatmentType)
	}
	if m.cleared_Patient {
		edges = append(edges, righttotreatment.EdgePatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RightToTreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	case righttotreatment.EdgeHospital:
		return m.cleared_Hospital
	case righttotreatment.EdgeRightToTreatmentType:
		return m.cleared_RightToTreatmentType
	case righttotreatment.EdgePatient:
		return m.cleared_Patient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RightToTreatmentMutation) ClearEdge(name string) error {
	switch name {
	case righttotreatment.EdgeHospital:
		m.ClearHospital()
		return nil
	case righttotreatment.EdgeRightToTreatmentType:
		m.ClearRightToTreatmentType()
		return nil
	case righttotreatment.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RightToTreatmentMutation) ResetEdge(name string) error {
	switch name {
	case righttotreatment.EdgeHospital:
		m.ResetHospital()
		return nil
	case righttotreatment.EdgeRightToTreatmentType:
		m.ResetRightToTreatmentType()
		return nil
	case righttotreatment.EdgePatient:
		m.ResetPatient()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment edge %s", name)
}

// RightToTreatmentTypeMutation represents an operation that mutates the RightToTreatmentType nodes in the graph.
type RightToTreatmentTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_TypeName     *string
	clearedFields map[string]struct{}
	_type         map[int]struct{}
	removed_type  map[int]struct{}
	cleared_type  bool
	done          bool
	oldValue      func(context.Context) (*RightToTreatmentType, error)
	predicates    []predicate.RightToTreatmentType
}

var _ ent.Mutation = (*RightToTreatmentTypeMutation)(nil)

// righttotreatmenttypeOption allows management of the mutation configuration using functional options.
type righttotreatmenttypeOption func(*RightToTreatmentTypeMutation)

// newRightToTreatmentTypeMutation creates new mutation for the RightToTreatmentType entity.
func newRightToTreatmentTypeMutation(c config, op Op, opts ...righttotreatmenttypeOption) *RightToTreatmentTypeMutation {
	m := &RightToTreatmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeRightToTreatmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRightToTreatmentTypeID sets the ID field of the mutation.
func withRightToTreatmentTypeID(id int) righttotreatmenttypeOption {
	return func(m *RightToTreatmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *RightToTreatmentType
		)
		m.oldValue = func(ctx context.Context) (*RightToTreatmentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RightToTreatmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRightToTreatmentType sets the old RightToTreatmentType of the mutation.
func withRightToTreatmentType(node *RightToTreatmentType) righttotreatmenttypeOption {
	return func(m *RightToTreatmentTypeMutation) {
		m.oldValue = func(context.Context) (*RightToTreatmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RightToTreatmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RightToTreatmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RightToTreatmentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTypeName sets the "TypeName" field.
func (m *RightToTreatmentTypeMutation) SetTypeName(s string) {
	m._TypeName = &s
}

// TypeName returns the value of the "TypeName" field in the mutation.
func (m *RightToTreatmentTypeMutation) TypeName() (r string, exists bool) {
	v := m._TypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "TypeName" field's value of the RightToTreatmentType entity.
// If the RightToTreatmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RightToTreatmentTypeMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "TypeName" field.
func (m *RightToTreatmentTypeMutation) ResetTypeName() {
	m._TypeName = nil
}

// AddTypeIDs adds the "type" edge to the RightToTreatment entity by ids.
func (m *RightToTreatmentTypeMutation) AddTypeIDs(ids ...int) {
	if m._type == nil {
		m._type = make(map[int]struct{})
	}
	for i := range ids {
		m._type[ids[i]] = struct{}{}
	}
}

// ClearType clears the "type" edge to the RightToTreatment entity.
func (m *RightToTreatmentTypeMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the "type" edge to the RightToTreatment entity was cleared.
func (m *RightToTreatmentTypeMutation) TypeCleared() bool {
	return m.cleared_type
}

// RemoveTypeIDs removes the "type" edge to the RightToTreatment entity by IDs.
func (m *RightToTreatmentTypeMutation) RemoveTypeIDs(ids ...int) {
	if m.removed_type == nil {
		m.removed_type = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_type[ids[i]] = struct{}{}
	}
}

// RemovedType returns the removed IDs of the "type" edge to the RightToTreatment entity.
func (m *RightToTreatmentTypeMutation) RemovedTypeIDs() (ids []int) {
	for id := range m.removed_type {
		ids = append(ids, id)
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
func (m *RightToTreatmentTypeMutation) TypeIDs() (ids []int) {
	for id := range m._type {
		ids = append(ids, id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *RightToTreatmentTypeMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
	m.removed_type = nil
}

// Op returns the operation name.
func (m *RightToTreatmentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RightToTreatmentType).
func (m *RightToTreatmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RightToTreatmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TypeName != nil {
		fields = append(fields, righttotreatmenttype.FieldTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RightToTreatmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		return m.TypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RightToTreatmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		return m.OldTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown RightToTreatmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown RightToTreatmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RightToTreatmentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RightToTreatmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RightToTreatmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RightToTreatmentTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RightToTreatmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RightToTreatmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ResetField(name string) error {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		m.ResetTypeName()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RightToTreatmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._type != nil {
		edges = append(edges, righttotreatmenttype.EdgeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RightToTreatmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case righttotreatmenttype.EdgeType:
		ids := make([]ent.Value, 0, len(m._type))
		for id := range m._type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RightToTreatmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_type != nil {
		edges = append(edges, righttotreatmenttype.EdgeType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RightToTreatmentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case righttotreatmenttype.EdgeType:
		ids := make([]ent.Value, 0, len(m.removed_type))
		for id := range m.removed_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RightToTreatmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_type {
		edges = append(edges, righttotreatmenttype.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RightToTreatmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case righttotreatmenttype.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RightToTreatmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case righttotreatmenttype.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatmentType edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	roomName                         *string
	clearedFields                    map[string]struct{}
	_RoomToAppointmentResults        map[int]struct{}
	removed_RoomToAppointmentResults map[int]struct{}
	cleared_RoomToAppointmentResults bool
	done                             bool
	oldValue                         func(context.Context) (*Room, error)
	predicates                       []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomName sets the "roomName" field.
func (m *RoomMutation) SetRoomName(s string) {
	m.roomName = &s
}

// RoomName returns the value of the "roomName" field in the mutation.
func (m *RoomMutation) RoomName() (r string, exists bool) {
	v := m.roomName
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomName returns the old "roomName" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldRoomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomName: %w", err)
	}
	return oldValue.RoomName, nil
}

// ResetRoomName resets all changes to the "roomName" field.
func (m *RoomMutation) ResetRoomName() {
	m.roomName = nil
}

// AddRoomToAppointmentResultIDs adds the "RoomToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *RoomMutation) AddRoomToAppointmentResultIDs(ids ...int) {
	if m._RoomToAppointmentResults == nil {
		m._RoomToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._RoomToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearRoomToAppointmentResults clears the "RoomToAppointmentResults" edge to the AppointmentResults entity.
func (m *RoomMutation) ClearRoomToAppointmentResults() {
	m.cleared_RoomToAppointmentResults = true
}

// RoomToAppointmentResultsCleared returns if the "RoomToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *RoomMutation) RoomToAppointmentResultsCleared() bool {
	return m.cleared_RoomToAppointmentResults
}

// RemoveRoomToAppointmentResultIDs removes the "RoomToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *RoomMutation) RemoveRoomToAppointmentResultIDs(ids ...int) {
	if m.removed_RoomToAppointmentResults == nil {
		m.removed_RoomToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_RoomToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedRoomToAppointmentResults returns the removed IDs of the "RoomToAppointmentResults" edge to the AppointmentResults entity.
func (m *RoomMutation) RemovedRoomToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_RoomToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// RoomToAppointmentResultsIDs returns the "RoomToAppointmentResults" edge IDs in the mutation.
func (m *RoomMutation) RoomToAppointmentResultsIDs() (ids []int) {
	for id := range m._RoomToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetRoomToAppointmentResults resets all changes to the "RoomToAppointmentResults" edge.
func (m *RoomMutation) ResetRoomToAppointmentResults() {
	m._RoomToAppointmentResults = nil
	m.cleared_RoomToAppointmentResults = false
	m.removed_RoomToAppointmentResults = nil
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.roomName != nil {
		fields = append(fields, room.FieldRoomName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRoomName:
		return m.RoomName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldRoomName:
		return m.OldRoomName(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldRoomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomName(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldRoomName:
		m.ResetRoomName()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._RoomToAppointmentResults != nil {
		edges = append(edges, room.EdgeRoomToAppointmentResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._RoomToAppointmentResults))
		for id := range m._RoomToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_RoomToAppointmentResults != nil {
		edges = append(edges, room.EdgeRoomToAppointmentResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_RoomToAppointmentResults))
		for id := range m.removed_RoomToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_RoomToAppointmentResults {
		edges = append(edges, room.EdgeRoomToAppointmentResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		return m.cleared_RoomToAppointmentResults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		m.ResetRoomToAppointmentResults()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// TreatmentTypeMutation represents an operation that mutates the TreatmentType nodes in the graph.
type TreatmentTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	_Type                            *string
	clearedFields                    map[string]struct{}
	_TreatmentTypeToDiagnosis        map[int]struct{}
	removed_TreatmentTypeToDiagnosis map[int]struct{}
	cleared_TreatmentTypeToDiagnosis bool
	done                             bool
	oldValue                         func(context.Context) (*TreatmentType, error)
	predicates                       []predicate.TreatmentType
}

var _ ent.Mutation = (*TreatmentTypeMutation)(nil)

// treatmenttypeOption allows management of the mutation configuration using functional options.
type treatmenttypeOption func(*TreatmentTypeMutation)

// newTreatmentTypeMutation creates new mutation for the TreatmentType entity.
func newTreatmentTypeMutation(c config, op Op, opts ...treatmenttypeOption) *TreatmentTypeMutation {
	m := &TreatmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentTypeID sets the ID field of the mutation.
func withTreatmentTypeID(id int) treatmenttypeOption {
	return func(m *TreatmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TreatmentType
		)
		m.oldValue = func(ctx context.Context) (*TreatmentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreatmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatmentType sets the old TreatmentType of the mutation.
func withTreatmentType(node *TreatmentType) treatmenttypeOption {
	return func(m *TreatmentTypeMutation) {
		m.oldValue = func(context.Context) (*TreatmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TreatmentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "Type" field.
func (m *TreatmentTypeMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *TreatmentTypeMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the TreatmentType entity.
// If the TreatmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreatmentTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *TreatmentTypeMutation) ResetType() {
	m._Type = nil
}

// AddTreatmentTypeToDiagnosiIDs adds the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity by ids.
func (m *TreatmentTypeMutation) AddTreatmentTypeToDiagnosiIDs(ids ...int) {
	if m._TreatmentTypeToDiagnosis == nil {
		m._TreatmentTypeToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m._TreatmentTypeToDiagnosis[ids[i]] = struct{}{}
	}
}

// ClearTreatmentTypeToDiagnosis clears the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity.
func (m *TreatmentTypeMutation) ClearTreatmentTypeToDiagnosis() {
	m.cleared_TreatmentTypeToDiagnosis = true
}

// TreatmentTypeToDiagnosisCleared returns if the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity was cleared.
func (m *TreatmentTypeMutation) TreatmentTypeToDiagnosisCleared() bool {
	return m.cleared_TreatmentTypeToDiagnosis
}

// RemoveTreatmentTypeToDiagnosiIDs removes the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity by IDs.
func (m *TreatmentTypeMutation) RemoveTreatmentTypeToDiagnosiIDs(ids ...int) {
	if m.removed_TreatmentTypeToDiagnosis == nil {
		m.removed_TreatmentTypeToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TreatmentTypeToDiagnosis[ids[i]] = struct{}{}
	}
}

// RemovedTreatmentTypeToDiagnosis returns the removed IDs of the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity.
func (m *TreatmentTypeMutation) RemovedTreatmentTypeToDiagnosisIDs() (ids []int) {
	for id := range m.removed_TreatmentTypeToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// TreatmentTypeToDiagnosisIDs returns the "TreatmentTypeToDiagnosis" edge IDs in the mutation.
func (m *TreatmentTypeMutation) TreatmentTypeToDiagnosisIDs() (ids []int) {
	for id := range m._TreatmentTypeToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// ResetTreatmentTypeToDiagnosis resets all changes to the "TreatmentTypeToDiagnosis" edge.
func (m *TreatmentTypeMutation) ResetTreatmentTypeToDiagnosis() {
	m._TreatmentTypeToDiagnosis = nil
	m.cleared_TreatmentTypeToDiagnosis = false
	m.removed_TreatmentTypeToDiagnosis = nil
}

// Op returns the operation name.
func (m *TreatmentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TreatmentType).
func (m *TreatmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreatmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Type != nil {
		fields = append(fields, treatmenttype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreatmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatmenttype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreatmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatmenttype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown TreatmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreatmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatmenttype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown TreatmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreatmentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreatmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreatmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreatmentTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreatmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TreatmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreatmentTypeMutation) ResetField(name string) error {
	switch name {
	case treatmenttype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown TreatmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreatmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._TreatmentTypeToDiagnosis != nil {
		edges = append(edges, treatmenttype.EdgeTreatmentTypeToDiagnosis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreatmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		ids := make([]ent.Value, 0, len(m._TreatmentTypeToDiagnosis))
		for id := range m._TreatmentTypeToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreatmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_TreatmentTypeToDiagnosis != nil {
		edges = append(edges, treatmenttype.EdgeTreatmentTypeToDiagnosis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreatmentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		ids := make([]ent.Value, 0, len(m.removed_TreatmentTypeToDiagnosis))
		for id := range m.removed_TreatmentTypeToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreatmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_TreatmentTypeToDiagnosis {
		edges = append(edges, treatmenttype.EdgeTreatmentTypeToDiagnosis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreatmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		return m.cleared_TreatmentTypeToDiagnosis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreatmentTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreatmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		m.ResetTreatmentTypeToDiagnosis()
		return nil
	}
	return fmt.Errorf("unknown TreatmentType edge %s", name)
}

// TriageResultMutation represents an operation that mutates the TriageResult nodes in the graph.
type TriageResultMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	symptom             *string
	triageDate          *time.Time
	clearedFields       map[string]struct{}
	urgencyLevel        *int
	clearedurgencyLevel bool
	department          *int
	cleareddepartment   bool
	nurse               *int
	clearednurse        bool
	patient             *int
	clearedpatient      bool
	done                bool
	oldValue            func(context.Context) (*TriageResult, error)
	predicates          []predicate.TriageResult
}

var _ ent.Mutation = (*TriageResultMutation)(nil)

// triageresultOption allows management of the mutation configuration using functional options.
type triageresultOption func(*TriageResultMutation)

// newTriageResultMutation creates new mutation for the TriageResult entity.
func newTriageResultMutation(c config, op Op, opts ...triageresultOption) *TriageResultMutation {
	m := &TriageResultMutation{
		config:        c,
		op:            op,
		typ:           TypeTriageResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTriageResultID sets the ID field of the mutation.
func withTriageResultID(id int) triageresultOption {
	return func(m *TriageResultMutation) {
		var (
			err   error
			once  sync.Once
			value *TriageResult
		)
		m.oldValue = func(ctx context.Context) (*TriageResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TriageResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTriageResult sets the old TriageResult of the mutation.
func withTriageResult(node *TriageResult) triageresultOption {
	return func(m *TriageResultMutation) {
		m.oldValue = func(context.Context) (*TriageResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TriageResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TriageResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TriageResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptom sets the "symptom" field.
func (m *TriageResultMutation) SetSymptom(s string) {
	m.symptom = &s
}

// Symptom returns the value of the "symptom" field in the mutation.
func (m *TriageResultMutation) Symptom() (r string, exists bool) {
	v := m.symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old "symptom" field's value of the TriageResult entity.
// If the TriageResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TriageResultMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom resets all changes to the "symptom" field.
func (m *TriageResultMutation) ResetSymptom() {
	m.symptom = nil
}

// SetTriageDate sets the "triageDate" field.
func (m *TriageResultMutation) SetTriageDate(t time.Time) {
	m.triageDate = &t
}

// TriageDate returns the value of the "triageDate" field in the mutation.
func (m *TriageResultMutation) TriageDate() (r time.Time, exists bool) {
	v := m.triageDate
	if v == nil {
		return
	}
	return *v, true
}

// OldTriageDate returns the old "triageDate" field's value of the TriageResult entity.
// If the TriageResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TriageResultMutation) OldTriageDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTriageDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTriageDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriageDate: %w", err)
	}
	return oldValue.TriageDate, nil
}

// ResetTriageDate resets all changes to the "triageDate" field.
func (m *TriageResultMutation) ResetTriageDate() {
	m.triageDate = nil
}

// SetUrgencyLevelID sets the "urgencyLevel" edge to the UrgencyLevel entity by id.
func (m *TriageResultMutation) SetUrgencyLevelID(id int) {
	m.urgencyLevel = &id
}

// ClearUrgencyLevel clears the "urgencyLevel" edge to the UrgencyLevel entity.
func (m *TriageResultMutation) ClearUrgencyLevel() {
	m.clearedurgencyLevel = true
}

// UrgencyLevelCleared returns if the "urgencyLevel" edge to the UrgencyLevel entity was cleared.
func (m *TriageResultMutation) UrgencyLevelCleared() bool {
	return m.clearedurgencyLevel
}

// UrgencyLevelID returns the "urgencyLevel" edge ID in the mutation.
func (m *TriageResultMutation) UrgencyLevelID() (id int, exists bool) {
	if m.urgencyLevel != nil {
		return *m.urgencyLevel, true
	}
	return
}

// UrgencyLevelIDs returns the "urgencyLevel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UrgencyLevelID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) UrgencyLevelIDs() (ids []int) {
	if id := m.urgencyLevel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUrgencyLevel resets all changes to the "urgencyLevel" edge.
func (m *TriageResultMutation) ResetUrgencyLevel() {
	m.urgencyLevel = nil
	m.clearedurgencyLevel = false
}

// SetDepartmentID sets the "department" edge to the Department entity by id.
func (m *TriageResultMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *TriageResultMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the "department" edge to the Department entity was cleared.
func (m *TriageResultMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the "department" edge ID in the mutation.
func (m *TriageResultMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *TriageResultMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetNurseID sets the "nurse" edge to the Nurse entity by id.
func (m *TriageResultMutation) SetNurseID(id int) {
	m.nurse = &id
}

// ClearNurse clears the "nurse" edge to the Nurse entity.
func (m *TriageResultMutation) ClearNurse() {
	m.clearednurse = true
}

// NurseCleared returns if the "nurse" edge to the Nurse entity was cleared.
func (m *TriageResultMutation) NurseCleared() bool {
	return m.clearednurse
}

// NurseID returns the "nurse" edge ID in the mutation.
func (m *TriageResultMutation) NurseID() (id int, exists bool) {
	if m.nurse != nil {
		return *m.nurse, true
	}
	return
}

// NurseIDs returns the "nurse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) NurseIDs() (ids []int) {
	if id := m.nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse resets all changes to the "nurse" edge.
func (m *TriageResultMutation) ResetNurse() {
	m.nurse = nil
	m.clearednurse = false
}

// SetPatientID sets the "patient" edge to the Patient entity by id.
func (m *TriageResultMutation) SetPatientID(id int) {
	m.patient = &id
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *TriageResultMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared returns if the "patient" edge to the Patient entity was cleared.
func (m *TriageResultMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the "patient" edge ID in the mutation.
func (m *TriageResultMutation) PatientID() (id int, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *TriageResultMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// Op returns the operation name.
func (m *TriageResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TriageResult).
func (m *TriageResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TriageResultMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.symptom != nil {
		fields = append(fields, triageresult.FieldSymptom)
	}
	if m.triageDate != nil {
		fields = append(fields, triageresult.FieldTriageDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TriageResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case triageresult.FieldSymptom:
		return m.Symptom()
	case triageresult.FieldTriageDate:
		return m.TriageDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TriageResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case triageresult.FieldSymptom:
		return m.OldSymptom(ctx)
	case triageresult.FieldTriageDate:
		return m.OldTriageDate(ctx)
	}
	return nil, fmt.Errorf("unknown TriageResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TriageResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case triageresult.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case triageresult.FieldTriageDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriageDate(v)
		return nil
	}
	return fmt.Errorf("unknown TriageResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TriageResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TriageResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TriageResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TriageResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TriageResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TriageResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TriageResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TriageResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TriageResultMutation) ResetField(name string) error {
	switch name {
	case triageresult.FieldSymptom:
		m.ResetSymptom()
		return nil
	case triageresult.FieldTriageDate:
		m.ResetTriageDate()
		return nil
	}
	return fmt.Errorf("unknown TriageResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TriageResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.urgencyLevel != nil {
		edges = append(edges, triageresult.EdgeUrgencyLevel)
	}
	if m.department != nil {
		edges = append(edges, triageresult.EdgeDepartment)
	}
	if m.nurse != nil {
		edges = append(edges, triageresult.EdgeNurse)
	}
	if m.patient != nil {
		edges = append(edges, triageresult.EdgePatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TriageResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case triageresult.EdgeUrgencyLevel:
		if id := m.urgencyLevel; id != nil {
			return []ent.Value{*id}
		}
	case triageresult.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case triageresult.EdgeNurse:
		if id := m.nurse; id != nil {
			return []ent.Value{*id}
		}
	case triageresult.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TriageResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TriageResultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TriageResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedurgencyLevel {
		edges = append(edges, triageresult.EdgeUrgencyLevel)
	}
	if m.cleareddepartment {
		edges = append(edges, triageresult.EdgeDepartment)
	}
	if m.clearednurse {
		edges = append(edges, triageresult.EdgeNurse)
	}
	if m.clearedpatient {
		edges = append(edges, triageresult.EdgePatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TriageResultMutation) EdgeCleared(name string) bool {
	switch name {
	case triageresult.EdgeUrgencyLevel:
		return m.clearedurgencyLevel
	case triageresult.EdgeDepartment:
		return m.cleareddepartment
	case triageresult.EdgeNurse:
		return m.clearednurse
	case triageresult.EdgePatient:
		return m.clearedpatient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TriageResultMutation) ClearEdge(name string) error {
	switch name {
	case triageresult.EdgeUrgencyLevel:
		m.ClearUrgencyLevel()
		return nil
	case triageresult.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case triageresult.EdgeNurse:
		m.ClearNurse()
		return nil
	case triageresult.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown TriageResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TriageResultMutation) ResetEdge(name string) error {
	switch name {
	case triageresult.EdgeUrgencyLevel:
		m.ResetUrgencyLevel()
		return nil
	case triageresult.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case triageresult.EdgeNurse:
		m.ResetNurse()
		return nil
	case triageresult.EdgePatient:
		m.ResetPatient()
		return nil
	}
	return fmt.Errorf("unknown TriageResult edge %s", name)
}

// UrgencyLevelMutation represents an operation that mutates the UrgencyLevel nodes in the graph.
type UrgencyLevelMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	urgencyName         *string
	clearedFields       map[string]struct{}
	triageResult        map[int]struct{}
	removedtriageResult map[int]struct{}
	clearedtriageResult bool
	done                bool
	oldValue            func(context.Context) (*UrgencyLevel, error)
	predicates          []predicate.UrgencyLevel
}

var _ ent.Mutation = (*UrgencyLevelMutation)(nil)

// urgencylevelOption allows management of the mutation configuration using functional options.
type urgencylevelOption func(*UrgencyLevelMutation)

// newUrgencyLevelMutation creates new mutation for the UrgencyLevel entity.
func newUrgencyLevelMutation(c config, op Op, opts ...urgencylevelOption) *UrgencyLevelMutation {
	m := &UrgencyLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeUrgencyLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUrgencyLevelID sets the ID field of the mutation.
func withUrgencyLevelID(id int) urgencylevelOption {
	return func(m *UrgencyLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *UrgencyLevel
		)
		m.oldValue = func(ctx context.Context) (*UrgencyLevel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UrgencyLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUrgencyLevel sets the old UrgencyLevel of the mutation.
func withUrgencyLevel(node *UrgencyLevel) urgencylevelOption {
	return func(m *UrgencyLevelMutation) {
		m.oldValue = func(context.Context) (*UrgencyLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UrgencyLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UrgencyLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UrgencyLevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUrgencyName sets the "urgencyName" field.
func (m *UrgencyLevelMutation) SetUrgencyName(s string) {
	m.urgencyName = &s
}

// UrgencyName returns the value of the "urgencyName" field in the mutation.
func (m *UrgencyLevelMutation) UrgencyName() (r string, exists bool) {
	v := m.urgencyName
	if v == nil {
		return
	}
	return *v, true
}

// OldUrgencyName returns the old "urgencyName" field's value of the UrgencyLevel entity.
// If the UrgencyLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrgencyLevelMutation) OldUrgencyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUrgencyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUrgencyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrgencyName: %w", err)
	}
	return oldValue.UrgencyName, nil
}

// ResetUrgencyName resets all changes to the "urgencyName" field.
func (m *UrgencyLevelMutation) ResetUrgencyName() {
	m.urgencyName = nil
}

// AddTriageResultIDs adds the "triageResult" edge to the TriageResult entity by ids.
func (m *UrgencyLevelMutation) AddTriageResultIDs(ids ...int) {
	if m.triageResult == nil {
		m.triageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.triageResult[ids[i]] = struct{}{}
	}
}

// ClearTriageResult clears the "triageResult" edge to the TriageResult entity.
func (m *UrgencyLevelMutation) ClearTriageResult() {
	m.clearedtriageResult = true
}

// TriageResultCleared returns if the "triageResult" edge to the TriageResult entity was cleared.
func (m *UrgencyLevelMutation) TriageResultCleared() bool {
	return m.clearedtriageResult
}

// RemoveTriageResultIDs removes the "triageResult" edge to the TriageResult entity by IDs.
func (m *UrgencyLevelMutation) RemoveTriageResultIDs(ids ...int) {
	if m.removedtriageResult == nil {
		m.removedtriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtriageResult[ids[i]] = struct{}{}
	}
}

// RemovedTriageResult returns the removed IDs of the "triageResult" edge to the TriageResult entity.
func (m *UrgencyLevelMutation) RemovedTriageResultIDs() (ids []int) {
	for id := range m.removedtriageResult {
		ids = append(ids, id)
	}
	return
}

// TriageResultIDs returns the "triageResult" edge IDs in the mutation.
func (m *UrgencyLevelMutation) TriageResultIDs() (ids []int) {
	for id := range m.triageResult {
		ids = append(ids, id)
	}
	return
}

// ResetTriageResult resets all changes to the "triageResult" edge.
func (m *UrgencyLevelMutation) ResetTriageResult() {
	m.triageResult = nil
	m.clearedtriageResult = false
	m.removedtriageResult = nil
}

// Op returns the operation name.
func (m *UrgencyLevelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UrgencyLevel).
func (m *UrgencyLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UrgencyLevelMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.urgencyName != nil {
		fields = append(fields, urgencylevel.FieldUrgencyName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UrgencyLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case urgencylevel.FieldUrgencyName:
		return m.UrgencyName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UrgencyLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case urgencylevel.FieldUrgencyName:
		return m.OldUrgencyName(ctx)
	}
	return nil, fmt.Errorf("unknown UrgencyLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UrgencyLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case urgencylevel.FieldUrgencyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrgencyName(v)
		return nil
	}
	return fmt.Errorf("unknown UrgencyLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UrgencyLevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UrgencyLevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UrgencyLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UrgencyLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UrgencyLevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UrgencyLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UrgencyLevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UrgencyLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UrgencyLevelMutation) ResetField(name string) error {
	switch name {
	case urgencylevel.FieldUrgencyName:
		m.ResetUrgencyName()
		return nil
	}
	return fmt.Errorf("unknown UrgencyLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UrgencyLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.triageResult != nil {
		edges = append(edges, urgencylevel.EdgeTriageResult)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UrgencyLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case urgencylevel.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.triageResult))
		for id := range m.triageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UrgencyLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtriageResult != nil {
		edges = append(edges, urgencylevel.EdgeTriageResult)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UrgencyLevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case urgencylevel.EdgeTriageResult:
		ids := make([]ent.Value, 0, len(m.removedtriageResult))
		for id := range m.removedtriageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UrgencyLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtriageResult {
		edges = append(edges, urgencylevel.EdgeTriageResult)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UrgencyLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case urgencylevel.EdgeTriageResult:
		return m.clearedtriageResult
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UrgencyLevelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UrgencyLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UrgencyLevelMutation) ResetEdge(name string) error {
	switch name {
	case urgencylevel.EdgeTriageResult:
		m.ResetTriageResult()
		return nil
	}
	return fmt.Errorf("unknown UrgencyLevel edge %s", name)
}
