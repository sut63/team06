// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team06/app/ent/appointmentresults"
	"github.com/team06/app/ent/bloodtype"
	"github.com/team06/app/ent/department"
	"github.com/team06/app/ent/diagnosis"
	"github.com/team06/app/ent/doctor"
	"github.com/team06/app/ent/gender"
	"github.com/team06/app/ent/hospital"
	"github.com/team06/app/ent/medicalprocedure"
	"github.com/team06/app/ent/medicalrecord"
	"github.com/team06/app/ent/nurse"
	"github.com/team06/app/ent/patient"
	"github.com/team06/app/ent/predicate"
	"github.com/team06/app/ent/prefix"
	"github.com/team06/app/ent/proceduretype"
	"github.com/team06/app/ent/righttotreatment"
	"github.com/team06/app/ent/righttotreatmenttype"
	"github.com/team06/app/ent/room"
	"github.com/team06/app/ent/treatmenttype"
	"github.com/team06/app/ent/triageresult"
	"github.com/team06/app/ent/urgencylevel"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppointmentResults   = "AppointmentResults"
	TypeBloodType            = "BloodType"
	TypeDepartment           = "Department"
	TypeDiagnosis            = "Diagnosis"
	TypeDoctor               = "Doctor"
	TypeGender               = "Gender"
	TypeHospital             = "Hospital"
	TypeMedicalProcedure     = "MedicalProcedure"
	TypeMedicalRecord        = "MedicalRecord"
	TypeNurse                = "Nurse"
	TypePatient              = "Patient"
	TypePrefix               = "Prefix"
	TypeProcedureType        = "ProcedureType"
	TypeRightToTreatment     = "RightToTreatment"
	TypeRightToTreatmentType = "RightToTreatmentType"
	TypeRoom                 = "Room"
	TypeTreatmentType        = "TreatmentType"
	TypeTriageResult         = "TriageResult"
	TypeUrgencyLevel         = "UrgencyLevel"
)

// AppointmentResultsMutation represents an operation that mutates the AppointmentResults nodes in the graph.
type AppointmentResultsMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	addtimeAppoint                     *time.Time
	addtimeSave                        *time.Time
	clearedFields                      map[string]struct{}
	appointmentResultsToPatient        *int
	clearedappointmentResultsToPatient bool
	appointmentResultsToNurse          *int
	clearedappointmentResultsToNurse   bool
	appointmentResultsToDoctor         *int
	clearedappointmentResultsToDoctor  bool
	appointmentResultsToRoom           *int
	clearedappointmentResultsToRoom    bool
	done                               bool
	oldValue                           func(context.Context) (*AppointmentResults, error)
	predicates                         []predicate.AppointmentResults
}

var _ ent.Mutation = (*AppointmentResultsMutation)(nil)

// appointmentresultsOption allows management of the mutation configuration using functional options.
type appointmentresultsOption func(*AppointmentResultsMutation)

// newAppointmentResultsMutation creates new mutation for the AppointmentResults entity.
func newAppointmentResultsMutation(c config, op Op, opts ...appointmentresultsOption) *AppointmentResultsMutation {
	m := &AppointmentResultsMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointmentResults,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentResultsID sets the ID field of the mutation.
func withAppointmentResultsID(id int) appointmentresultsOption {
	return func(m *AppointmentResultsMutation) {
		var (
			err   error
			once  sync.Once
			value *AppointmentResults
		)
		m.oldValue = func(ctx context.Context) (*AppointmentResults, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppointmentResults.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointmentResults sets the old AppointmentResults of the mutation.
func withAppointmentResults(node *AppointmentResults) appointmentresultsOption {
	return func(m *AppointmentResultsMutation) {
		m.oldValue = func(context.Context) (*AppointmentResults, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentResultsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentResultsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AppointmentResultsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddtimeAppoint sets the "addtimeAppoint" field.
func (m *AppointmentResultsMutation) SetAddtimeAppoint(t time.Time) {
	m.addtimeAppoint = &t
}

// AddtimeAppoint returns the value of the "addtimeAppoint" field in the mutation.
func (m *AppointmentResultsMutation) AddtimeAppoint() (r time.Time, exists bool) {
	v := m.addtimeAppoint
	if v == nil {
		return
	}
	return *v, true
}

// OldAddtimeAppoint returns the old "addtimeAppoint" field's value of the AppointmentResults entity.
// If the AppointmentResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentResultsMutation) OldAddtimeAppoint(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddtimeAppoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddtimeAppoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddtimeAppoint: %w", err)
	}
	return oldValue.AddtimeAppoint, nil
}

// ResetAddtimeAppoint resets all changes to the "addtimeAppoint" field.
func (m *AppointmentResultsMutation) ResetAddtimeAppoint() {
	m.addtimeAppoint = nil
}

// SetAddtimeSave sets the "addtimeSave" field.
func (m *AppointmentResultsMutation) SetAddtimeSave(t time.Time) {
	m.addtimeSave = &t
}

// AddtimeSave returns the value of the "addtimeSave" field in the mutation.
func (m *AppointmentResultsMutation) AddtimeSave() (r time.Time, exists bool) {
	v := m.addtimeSave
	if v == nil {
		return
	}
	return *v, true
}

// OldAddtimeSave returns the old "addtimeSave" field's value of the AppointmentResults entity.
// If the AppointmentResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentResultsMutation) OldAddtimeSave(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddtimeSave is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddtimeSave requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddtimeSave: %w", err)
	}
	return oldValue.AddtimeSave, nil
}

// ResetAddtimeSave resets all changes to the "addtimeSave" field.
func (m *AppointmentResultsMutation) ResetAddtimeSave() {
	m.addtimeSave = nil
}

// SetAppointmentResultsToPatientID sets the "appointmentResultsToPatient" edge to the Patient entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToPatientID(id int) {
	m.appointmentResultsToPatient = &id
}

// ClearAppointmentResultsToPatient clears the "appointmentResultsToPatient" edge to the Patient entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToPatient() {
	m.clearedappointmentResultsToPatient = true
}

// AppointmentResultsToPatientCleared returns if the "appointmentResultsToPatient" edge to the Patient entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToPatientCleared() bool {
	return m.clearedappointmentResultsToPatient
}

// AppointmentResultsToPatientID returns the "appointmentResultsToPatient" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToPatientID() (id int, exists bool) {
	if m.appointmentResultsToPatient != nil {
		return *m.appointmentResultsToPatient, true
	}
	return
}

// AppointmentResultsToPatientIDs returns the "appointmentResultsToPatient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToPatientID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToPatientIDs() (ids []int) {
	if id := m.appointmentResultsToPatient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToPatient resets all changes to the "appointmentResultsToPatient" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToPatient() {
	m.appointmentResultsToPatient = nil
	m.clearedappointmentResultsToPatient = false
}

// SetAppointmentResultsToNurseID sets the "appointmentResultsToNurse" edge to the Nurse entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToNurseID(id int) {
	m.appointmentResultsToNurse = &id
}

// ClearAppointmentResultsToNurse clears the "appointmentResultsToNurse" edge to the Nurse entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToNurse() {
	m.clearedappointmentResultsToNurse = true
}

// AppointmentResultsToNurseCleared returns if the "appointmentResultsToNurse" edge to the Nurse entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToNurseCleared() bool {
	return m.clearedappointmentResultsToNurse
}

// AppointmentResultsToNurseID returns the "appointmentResultsToNurse" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToNurseID() (id int, exists bool) {
	if m.appointmentResultsToNurse != nil {
		return *m.appointmentResultsToNurse, true
	}
	return
}

// AppointmentResultsToNurseIDs returns the "appointmentResultsToNurse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToNurseID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToNurseIDs() (ids []int) {
	if id := m.appointmentResultsToNurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToNurse resets all changes to the "appointmentResultsToNurse" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToNurse() {
	m.appointmentResultsToNurse = nil
	m.clearedappointmentResultsToNurse = false
}

// SetAppointmentResultsToDoctorID sets the "appointmentResultsToDoctor" edge to the Doctor entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToDoctorID(id int) {
	m.appointmentResultsToDoctor = &id
}

// ClearAppointmentResultsToDoctor clears the "appointmentResultsToDoctor" edge to the Doctor entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToDoctor() {
	m.clearedappointmentResultsToDoctor = true
}

// AppointmentResultsToDoctorCleared returns if the "appointmentResultsToDoctor" edge to the Doctor entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToDoctorCleared() bool {
	return m.clearedappointmentResultsToDoctor
}

// AppointmentResultsToDoctorID returns the "appointmentResultsToDoctor" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToDoctorID() (id int, exists bool) {
	if m.appointmentResultsToDoctor != nil {
		return *m.appointmentResultsToDoctor, true
	}
	return
}

// AppointmentResultsToDoctorIDs returns the "appointmentResultsToDoctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToDoctorID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToDoctorIDs() (ids []int) {
	if id := m.appointmentResultsToDoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToDoctor resets all changes to the "appointmentResultsToDoctor" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToDoctor() {
	m.appointmentResultsToDoctor = nil
	m.clearedappointmentResultsToDoctor = false
}

// SetAppointmentResultsToRoomID sets the "appointmentResultsToRoom" edge to the Room entity by id.
func (m *AppointmentResultsMutation) SetAppointmentResultsToRoomID(id int) {
	m.appointmentResultsToRoom = &id
}

// ClearAppointmentResultsToRoom clears the "appointmentResultsToRoom" edge to the Room entity.
func (m *AppointmentResultsMutation) ClearAppointmentResultsToRoom() {
	m.clearedappointmentResultsToRoom = true
}

// AppointmentResultsToRoomCleared returns if the "appointmentResultsToRoom" edge to the Room entity was cleared.
func (m *AppointmentResultsMutation) AppointmentResultsToRoomCleared() bool {
	return m.clearedappointmentResultsToRoom
}

// AppointmentResultsToRoomID returns the "appointmentResultsToRoom" edge ID in the mutation.
func (m *AppointmentResultsMutation) AppointmentResultsToRoomID() (id int, exists bool) {
	if m.appointmentResultsToRoom != nil {
		return *m.appointmentResultsToRoom, true
	}
	return
}

// AppointmentResultsToRoomIDs returns the "appointmentResultsToRoom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentResultsToRoomID instead. It exists only for internal usage by the builders.
func (m *AppointmentResultsMutation) AppointmentResultsToRoomIDs() (ids []int) {
	if id := m.appointmentResultsToRoom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentResultsToRoom resets all changes to the "appointmentResultsToRoom" edge.
func (m *AppointmentResultsMutation) ResetAppointmentResultsToRoom() {
	m.appointmentResultsToRoom = nil
	m.clearedappointmentResultsToRoom = false
}

// Op returns the operation name.
func (m *AppointmentResultsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppointmentResults).
func (m *AppointmentResultsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppointmentResultsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.addtimeAppoint != nil {
		fields = append(fields, appointmentresults.FieldAddtimeAppoint)
	}
	if m.addtimeSave != nil {
		fields = append(fields, appointmentresults.FieldAddtimeSave)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppointmentResultsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		return m.AddtimeAppoint()
	case appointmentresults.FieldAddtimeSave:
		return m.AddtimeSave()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppointmentResultsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		return m.OldAddtimeAppoint(ctx)
	case appointmentresults.FieldAddtimeSave:
		return m.OldAddtimeSave(ctx)
	}
	return nil, fmt.Errorf("unknown AppointmentResults field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentResultsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddtimeAppoint(v)
		return nil
	case appointmentresults.FieldAddtimeSave:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddtimeSave(v)
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppointmentResultsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppointmentResultsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentResultsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppointmentResults numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppointmentResultsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppointmentResultsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentResultsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppointmentResults nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppointmentResultsMutation) ResetField(name string) error {
	switch name {
	case appointmentresults.FieldAddtimeAppoint:
		m.ResetAddtimeAppoint()
		return nil
	case appointmentresults.FieldAddtimeSave:
		m.ResetAddtimeSave()
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppointmentResultsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.appointmentResultsToPatient != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToPatient)
	}
	if m.appointmentResultsToNurse != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToNurse)
	}
	if m.appointmentResultsToDoctor != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToDoctor)
	}
	if m.appointmentResultsToRoom != nil {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToRoom)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppointmentResultsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		if id := m.appointmentResultsToPatient; id != nil {
			return []ent.Value{*id}
		}
	case appointmentresults.EdgeAppointmentResultsToNurse:
		if id := m.appointmentResultsToNurse; id != nil {
			return []ent.Value{*id}
		}
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		if id := m.appointmentResultsToDoctor; id != nil {
			return []ent.Value{*id}
		}
	case appointmentresults.EdgeAppointmentResultsToRoom:
		if id := m.appointmentResultsToRoom; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppointmentResultsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppointmentResultsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppointmentResultsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedappointmentResultsToPatient {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToPatient)
	}
	if m.clearedappointmentResultsToNurse {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToNurse)
	}
	if m.clearedappointmentResultsToDoctor {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToDoctor)
	}
	if m.clearedappointmentResultsToRoom {
		edges = append(edges, appointmentresults.EdgeAppointmentResultsToRoom)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppointmentResultsMutation) EdgeCleared(name string) bool {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		return m.clearedappointmentResultsToPatient
	case appointmentresults.EdgeAppointmentResultsToNurse:
		return m.clearedappointmentResultsToNurse
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		return m.clearedappointmentResultsToDoctor
	case appointmentresults.EdgeAppointmentResultsToRoom:
		return m.clearedappointmentResultsToRoom
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppointmentResultsMutation) ClearEdge(name string) error {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		m.ClearAppointmentResultsToPatient()
		return nil
	case appointmentresults.EdgeAppointmentResultsToNurse:
		m.ClearAppointmentResultsToNurse()
		return nil
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		m.ClearAppointmentResultsToDoctor()
		return nil
	case appointmentresults.EdgeAppointmentResultsToRoom:
		m.ClearAppointmentResultsToRoom()
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppointmentResultsMutation) ResetEdge(name string) error {
	switch name {
	case appointmentresults.EdgeAppointmentResultsToPatient:
		m.ResetAppointmentResultsToPatient()
		return nil
	case appointmentresults.EdgeAppointmentResultsToNurse:
		m.ResetAppointmentResultsToNurse()
		return nil
	case appointmentresults.EdgeAppointmentResultsToDoctor:
		m.ResetAppointmentResultsToDoctor()
		return nil
	case appointmentresults.EdgeAppointmentResultsToRoom:
		m.ResetAppointmentResultsToRoom()
		return nil
	}
	return fmt.Errorf("unknown AppointmentResults edge %s", name)
}

// BloodTypeMutation represents an operation that mutates the BloodType nodes in the graph.
type BloodTypeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	blood                      *string
	clearedFields              map[string]struct{}
	_BloodTypeToPatient        map[int]struct{}
	removed_BloodTypeToPatient map[int]struct{}
	cleared_BloodTypeToPatient bool
	done                       bool
	oldValue                   func(context.Context) (*BloodType, error)
	predicates                 []predicate.BloodType
}

var _ ent.Mutation = (*BloodTypeMutation)(nil)

// bloodtypeOption allows management of the mutation configuration using functional options.
type bloodtypeOption func(*BloodTypeMutation)

// newBloodTypeMutation creates new mutation for the BloodType entity.
func newBloodTypeMutation(c config, op Op, opts ...bloodtypeOption) *BloodTypeMutation {
	m := &BloodTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBloodType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBloodTypeID sets the ID field of the mutation.
func withBloodTypeID(id int) bloodtypeOption {
	return func(m *BloodTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *BloodType
		)
		m.oldValue = func(ctx context.Context) (*BloodType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BloodType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBloodType sets the old BloodType of the mutation.
func withBloodType(node *BloodType) bloodtypeOption {
	return func(m *BloodTypeMutation) {
		m.oldValue = func(context.Context) (*BloodType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BloodTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BloodTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BloodTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBlood sets the "blood" field.
func (m *BloodTypeMutation) SetBlood(s string) {
	m.blood = &s
}

// Blood returns the value of the "blood" field in the mutation.
func (m *BloodTypeMutation) Blood() (r string, exists bool) {
	v := m.blood
	if v == nil {
		return
	}
	return *v, true
}

// OldBlood returns the old "blood" field's value of the BloodType entity.
// If the BloodType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BloodTypeMutation) OldBlood(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBlood is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBlood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlood: %w", err)
	}
	return oldValue.Blood, nil
}

// ResetBlood resets all changes to the "blood" field.
func (m *BloodTypeMutation) ResetBlood() {
	m.blood = nil
}

// AddBloodTypeToPatientIDs adds the "BloodTypeToPatient" edge to the Patient entity by ids.
func (m *BloodTypeMutation) AddBloodTypeToPatientIDs(ids ...int) {
	if m._BloodTypeToPatient == nil {
		m._BloodTypeToPatient = make(map[int]struct{})
	}
	for i := range ids {
		m._BloodTypeToPatient[ids[i]] = struct{}{}
	}
}

// ClearBloodTypeToPatient clears the "BloodTypeToPatient" edge to the Patient entity.
func (m *BloodTypeMutation) ClearBloodTypeToPatient() {
	m.cleared_BloodTypeToPatient = true
}

// BloodTypeToPatientCleared returns if the "BloodTypeToPatient" edge to the Patient entity was cleared.
func (m *BloodTypeMutation) BloodTypeToPatientCleared() bool {
	return m.cleared_BloodTypeToPatient
}

// RemoveBloodTypeToPatientIDs removes the "BloodTypeToPatient" edge to the Patient entity by IDs.
func (m *BloodTypeMutation) RemoveBloodTypeToPatientIDs(ids ...int) {
	if m.removed_BloodTypeToPatient == nil {
		m.removed_BloodTypeToPatient = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_BloodTypeToPatient[ids[i]] = struct{}{}
	}
}

// RemovedBloodTypeToPatient returns the removed IDs of the "BloodTypeToPatient" edge to the Patient entity.
func (m *BloodTypeMutation) RemovedBloodTypeToPatientIDs() (ids []int) {
	for id := range m.removed_BloodTypeToPatient {
		ids = append(ids, id)
	}
	return
}

// BloodTypeToPatientIDs returns the "BloodTypeToPatient" edge IDs in the mutation.
func (m *BloodTypeMutation) BloodTypeToPatientIDs() (ids []int) {
	for id := range m._BloodTypeToPatient {
		ids = append(ids, id)
	}
	return
}

// ResetBloodTypeToPatient resets all changes to the "BloodTypeToPatient" edge.
func (m *BloodTypeMutation) ResetBloodTypeToPatient() {
	m._BloodTypeToPatient = nil
	m.cleared_BloodTypeToPatient = false
	m.removed_BloodTypeToPatient = nil
}

// Op returns the operation name.
func (m *BloodTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BloodType).
func (m *BloodTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BloodTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.blood != nil {
		fields = append(fields, bloodtype.FieldBlood)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BloodTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bloodtype.FieldBlood:
		return m.Blood()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BloodTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bloodtype.FieldBlood:
		return m.OldBlood(ctx)
	}
	return nil, fmt.Errorf("unknown BloodType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BloodTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bloodtype.FieldBlood:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlood(v)
		return nil
	}
	return fmt.Errorf("unknown BloodType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BloodTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BloodTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BloodTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BloodType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BloodTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BloodTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BloodTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BloodType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BloodTypeMutation) ResetField(name string) error {
	switch name {
	case bloodtype.FieldBlood:
		m.ResetBlood()
		return nil
	}
	return fmt.Errorf("unknown BloodType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BloodTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._BloodTypeToPatient != nil {
		edges = append(edges, bloodtype.EdgeBloodTypeToPatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BloodTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgeBloodTypeToPatient:
		ids := make([]ent.Value, 0, len(m._BloodTypeToPatient))
		for id := range m._BloodTypeToPatient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BloodTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_BloodTypeToPatient != nil {
		edges = append(edges, bloodtype.EdgeBloodTypeToPatient)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BloodTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgeBloodTypeToPatient:
		ids := make([]ent.Value, 0, len(m.removed_BloodTypeToPatient))
		for id := range m.removed_BloodTypeToPatient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BloodTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_BloodTypeToPatient {
		edges = append(edges, bloodtype.EdgeBloodTypeToPatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BloodTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case bloodtype.EdgeBloodTypeToPatient:
		return m.cleared_BloodTypeToPatient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BloodTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BloodType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BloodTypeMutation) ResetEdge(name string) error {
	switch name {
	case bloodtype.EdgeBloodTypeToPatient:
		m.ResetBloodTypeToPatient()
		return nil
	}
	return fmt.Errorf("unknown BloodType edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	departmentName                  *string
	clearedFields                   map[string]struct{}
	departmentToTriageResult        map[int]struct{}
	removeddepartmentToTriageResult map[int]struct{}
	cleareddepartmentToTriageResult bool
	done                            bool
	oldValue                        func(context.Context) (*Department, error)
	predicates                      []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDepartmentName sets the "departmentName" field.
func (m *DepartmentMutation) SetDepartmentName(s string) {
	m.departmentName = &s
}

// DepartmentName returns the value of the "departmentName" field in the mutation.
func (m *DepartmentMutation) DepartmentName() (r string, exists bool) {
	v := m.departmentName
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentName returns the old "departmentName" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDepartmentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepartmentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepartmentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentName: %w", err)
	}
	return oldValue.DepartmentName, nil
}

// ResetDepartmentName resets all changes to the "departmentName" field.
func (m *DepartmentMutation) ResetDepartmentName() {
	m.departmentName = nil
}

// AddDepartmentToTriageResultIDs adds the "departmentToTriageResult" edge to the TriageResult entity by ids.
func (m *DepartmentMutation) AddDepartmentToTriageResultIDs(ids ...int) {
	if m.departmentToTriageResult == nil {
		m.departmentToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.departmentToTriageResult[ids[i]] = struct{}{}
	}
}

// ClearDepartmentToTriageResult clears the "departmentToTriageResult" edge to the TriageResult entity.
func (m *DepartmentMutation) ClearDepartmentToTriageResult() {
	m.cleareddepartmentToTriageResult = true
}

// DepartmentToTriageResultCleared returns if the "departmentToTriageResult" edge to the TriageResult entity was cleared.
func (m *DepartmentMutation) DepartmentToTriageResultCleared() bool {
	return m.cleareddepartmentToTriageResult
}

// RemoveDepartmentToTriageResultIDs removes the "departmentToTriageResult" edge to the TriageResult entity by IDs.
func (m *DepartmentMutation) RemoveDepartmentToTriageResultIDs(ids ...int) {
	if m.removeddepartmentToTriageResult == nil {
		m.removeddepartmentToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartmentToTriageResult[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentToTriageResult returns the removed IDs of the "departmentToTriageResult" edge to the TriageResult entity.
func (m *DepartmentMutation) RemovedDepartmentToTriageResultIDs() (ids []int) {
	for id := range m.removeddepartmentToTriageResult {
		ids = append(ids, id)
	}
	return
}

// DepartmentToTriageResultIDs returns the "departmentToTriageResult" edge IDs in the mutation.
func (m *DepartmentMutation) DepartmentToTriageResultIDs() (ids []int) {
	for id := range m.departmentToTriageResult {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentToTriageResult resets all changes to the "departmentToTriageResult" edge.
func (m *DepartmentMutation) ResetDepartmentToTriageResult() {
	m.departmentToTriageResult = nil
	m.cleareddepartmentToTriageResult = false
	m.removeddepartmentToTriageResult = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.departmentName != nil {
		fields = append(fields, department.FieldDepartmentName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDepartmentName:
		return m.DepartmentName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDepartmentName:
		return m.OldDepartmentName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDepartmentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDepartmentName:
		m.ResetDepartmentName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.departmentToTriageResult != nil {
		edges = append(edges, department.EdgeDepartmentToTriageResult)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentToTriageResult:
		ids := make([]ent.Value, 0, len(m.departmentToTriageResult))
		for id := range m.departmentToTriageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddepartmentToTriageResult != nil {
		edges = append(edges, department.EdgeDepartmentToTriageResult)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentToTriageResult:
		ids := make([]ent.Value, 0, len(m.removeddepartmentToTriageResult))
		for id := range m.removeddepartmentToTriageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddepartmentToTriageResult {
		edges = append(edges, department.EdgeDepartmentToTriageResult)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeDepartmentToTriageResult:
		return m.cleareddepartmentToTriageResult
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeDepartmentToTriageResult:
		m.ResetDepartmentToTriageResult()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DiagnosisMutation represents an operation that mutates the Diagnosis nodes in the graph.
type DiagnosisMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	symptom             *string
	_Opinionresult      *string
	clearedFields       map[string]struct{}
	_Doctor_name        *int
	cleared_Doctor_name bool
	_Patient            *int
	cleared_Patient     bool
	_type               *int
	cleared_type        bool
	done                bool
	oldValue            func(context.Context) (*Diagnosis, error)
	predicates          []predicate.Diagnosis
}

var _ ent.Mutation = (*DiagnosisMutation)(nil)

// diagnosisOption allows management of the mutation configuration using functional options.
type diagnosisOption func(*DiagnosisMutation)

// newDiagnosisMutation creates new mutation for the Diagnosis entity.
func newDiagnosisMutation(c config, op Op, opts ...diagnosisOption) *DiagnosisMutation {
	m := &DiagnosisMutation{
		config:        c,
		op:            op,
		typ:           TypeDiagnosis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiagnosisID sets the ID field of the mutation.
func withDiagnosisID(id int) diagnosisOption {
	return func(m *DiagnosisMutation) {
		var (
			err   error
			once  sync.Once
			value *Diagnosis
		)
		m.oldValue = func(ctx context.Context) (*Diagnosis, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Diagnosis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiagnosis sets the old Diagnosis of the mutation.
func withDiagnosis(node *Diagnosis) diagnosisOption {
	return func(m *DiagnosisMutation) {
		m.oldValue = func(context.Context) (*Diagnosis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiagnosisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiagnosisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DiagnosisMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptom sets the "symptom" field.
func (m *DiagnosisMutation) SetSymptom(s string) {
	m.symptom = &s
}

// Symptom returns the value of the "symptom" field in the mutation.
func (m *DiagnosisMutation) Symptom() (r string, exists bool) {
	v := m.symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old "symptom" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom resets all changes to the "symptom" field.
func (m *DiagnosisMutation) ResetSymptom() {
	m.symptom = nil
}

// SetOpinionresult sets the "Opinionresult" field.
func (m *DiagnosisMutation) SetOpinionresult(s string) {
	m._Opinionresult = &s
}

// Opinionresult returns the value of the "Opinionresult" field in the mutation.
func (m *DiagnosisMutation) Opinionresult() (r string, exists bool) {
	v := m._Opinionresult
	if v == nil {
		return
	}
	return *v, true
}

// OldOpinionresult returns the old "Opinionresult" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldOpinionresult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpinionresult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpinionresult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpinionresult: %w", err)
	}
	return oldValue.Opinionresult, nil
}

// ResetOpinionresult resets all changes to the "Opinionresult" field.
func (m *DiagnosisMutation) ResetOpinionresult() {
	m._Opinionresult = nil
}

// SetDoctorNameID sets the "Doctor_name" edge to the Doctor entity by id.
func (m *DiagnosisMutation) SetDoctorNameID(id int) {
	m._Doctor_name = &id
}

// ClearDoctorName clears the "Doctor_name" edge to the Doctor entity.
func (m *DiagnosisMutation) ClearDoctorName() {
	m.cleared_Doctor_name = true
}

// DoctorNameCleared returns if the "Doctor_name" edge to the Doctor entity was cleared.
func (m *DiagnosisMutation) DoctorNameCleared() bool {
	return m.cleared_Doctor_name
}

// DoctorNameID returns the "Doctor_name" edge ID in the mutation.
func (m *DiagnosisMutation) DoctorNameID() (id int, exists bool) {
	if m._Doctor_name != nil {
		return *m._Doctor_name, true
	}
	return
}

// DoctorNameIDs returns the "Doctor_name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorNameID instead. It exists only for internal usage by the builders.
func (m *DiagnosisMutation) DoctorNameIDs() (ids []int) {
	if id := m._Doctor_name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctorName resets all changes to the "Doctor_name" edge.
func (m *DiagnosisMutation) ResetDoctorName() {
	m._Doctor_name = nil
	m.cleared_Doctor_name = false
}

// SetPatientID sets the "Patient" edge to the Patient entity by id.
func (m *DiagnosisMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the "Patient" edge to the Patient entity.
func (m *DiagnosisMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the "Patient" edge to the Patient entity was cleared.
func (m *DiagnosisMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the "Patient" edge ID in the mutation.
func (m *DiagnosisMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the "Patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *DiagnosisMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "Patient" edge.
func (m *DiagnosisMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// SetTypeID sets the "type" edge to the TreatmentType entity by id.
func (m *DiagnosisMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the TreatmentType entity.
func (m *DiagnosisMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the "type" edge to the TreatmentType entity was cleared.
func (m *DiagnosisMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *DiagnosisMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *DiagnosisMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *DiagnosisMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Op returns the operation name.
func (m *DiagnosisMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Diagnosis).
func (m *DiagnosisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiagnosisMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.symptom != nil {
		fields = append(fields, diagnosis.FieldSymptom)
	}
	if m._Opinionresult != nil {
		fields = append(fields, diagnosis.FieldOpinionresult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiagnosisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case diagnosis.FieldSymptom:
		return m.Symptom()
	case diagnosis.FieldOpinionresult:
		return m.Opinionresult()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiagnosisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case diagnosis.FieldSymptom:
		return m.OldSymptom(ctx)
	case diagnosis.FieldOpinionresult:
		return m.OldOpinionresult(ctx)
	}
	return nil, fmt.Errorf("unknown Diagnosis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case diagnosis.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case diagnosis.FieldOpinionresult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpinionresult(v)
		return nil
	}
	return fmt.Errorf("unknown Diagnosis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiagnosisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiagnosisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Diagnosis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiagnosisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiagnosisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiagnosisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Diagnosis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiagnosisMutation) ResetField(name string) error {
	switch name {
	case diagnosis.FieldSymptom:
		m.ResetSymptom()
		return nil
	case diagnosis.FieldOpinionresult:
		m.ResetOpinionresult()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiagnosisMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Doctor_name != nil {
		edges = append(edges, diagnosis.EdgeDoctorName)
	}
	if m._Patient != nil {
		edges = append(edges, diagnosis.EdgePatient)
	}
	if m._type != nil {
		edges = append(edges, diagnosis.EdgeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiagnosisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case diagnosis.EdgeDoctorName:
		if id := m._Doctor_name; id != nil {
			return []ent.Value{*id}
		}
	case diagnosis.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	case diagnosis.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiagnosisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiagnosisMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiagnosisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Doctor_name {
		edges = append(edges, diagnosis.EdgeDoctorName)
	}
	if m.cleared_Patient {
		edges = append(edges, diagnosis.EdgePatient)
	}
	if m.cleared_type {
		edges = append(edges, diagnosis.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiagnosisMutation) EdgeCleared(name string) bool {
	switch name {
	case diagnosis.EdgeDoctorName:
		return m.cleared_Doctor_name
	case diagnosis.EdgePatient:
		return m.cleared_Patient
	case diagnosis.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiagnosisMutation) ClearEdge(name string) error {
	switch name {
	case diagnosis.EdgeDoctorName:
		m.ClearDoctorName()
		return nil
	case diagnosis.EdgePatient:
		m.ClearPatient()
		return nil
	case diagnosis.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiagnosisMutation) ResetEdge(name string) error {
	switch name {
	case diagnosis.EdgeDoctorName:
		m.ResetDoctorName()
		return nil
	case diagnosis.EdgePatient:
		m.ResetPatient()
		return nil
	case diagnosis.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis edge %s", name)
}

// DoctorMutation represents an operation that mutates the Doctor nodes in the graph.
type DoctorMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	doctorName                         *string
	doctorUsername                     *string
	doctorPassword                     *string
	clearedFields                      map[string]struct{}
	_DoctorToDiagnosis                 map[int]struct{}
	removed_DoctorToDiagnosis          map[int]struct{}
	cleared_DoctorToDiagnosis          bool
	_DoctorToAppointmentResults        map[int]struct{}
	removed_DoctorToAppointmentResults map[int]struct{}
	cleared_DoctorToAppointmentResults bool
	_DoctorToMedicalProcedure          map[int]struct{}
	removed_DoctorToMedicalProcedure   map[int]struct{}
	cleared_DoctorToMedicalProcedure   bool
	done                               bool
	oldValue                           func(context.Context) (*Doctor, error)
	predicates                         []predicate.Doctor
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows management of the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for the Doctor entity.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the ID field of the mutation.
func withDoctorID(id int) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDoctorName sets the "doctorName" field.
func (m *DoctorMutation) SetDoctorName(s string) {
	m.doctorName = &s
}

// DoctorName returns the value of the "doctorName" field in the mutation.
func (m *DoctorMutation) DoctorName() (r string, exists bool) {
	v := m.doctorName
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorName returns the old "doctorName" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDoctorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorName: %w", err)
	}
	return oldValue.DoctorName, nil
}

// ResetDoctorName resets all changes to the "doctorName" field.
func (m *DoctorMutation) ResetDoctorName() {
	m.doctorName = nil
}

// SetDoctorUsername sets the "doctorUsername" field.
func (m *DoctorMutation) SetDoctorUsername(s string) {
	m.doctorUsername = &s
}

// DoctorUsername returns the value of the "doctorUsername" field in the mutation.
func (m *DoctorMutation) DoctorUsername() (r string, exists bool) {
	v := m.doctorUsername
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorUsername returns the old "doctorUsername" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDoctorUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorUsername: %w", err)
	}
	return oldValue.DoctorUsername, nil
}

// ResetDoctorUsername resets all changes to the "doctorUsername" field.
func (m *DoctorMutation) ResetDoctorUsername() {
	m.doctorUsername = nil
}

// SetDoctorPassword sets the "doctorPassword" field.
func (m *DoctorMutation) SetDoctorPassword(s string) {
	m.doctorPassword = &s
}

// DoctorPassword returns the value of the "doctorPassword" field in the mutation.
func (m *DoctorMutation) DoctorPassword() (r string, exists bool) {
	v := m.doctorPassword
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorPassword returns the old "doctorPassword" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDoctorPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorPassword: %w", err)
	}
	return oldValue.DoctorPassword, nil
}

// ResetDoctorPassword resets all changes to the "doctorPassword" field.
func (m *DoctorMutation) ResetDoctorPassword() {
	m.doctorPassword = nil
}

// AddDoctorToDiagnosiIDs adds the "DoctorToDiagnosis" edge to the Diagnosis entity by ids.
func (m *DoctorMutation) AddDoctorToDiagnosiIDs(ids ...int) {
	if m._DoctorToDiagnosis == nil {
		m._DoctorToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m._DoctorToDiagnosis[ids[i]] = struct{}{}
	}
}

// ClearDoctorToDiagnosis clears the "DoctorToDiagnosis" edge to the Diagnosis entity.
func (m *DoctorMutation) ClearDoctorToDiagnosis() {
	m.cleared_DoctorToDiagnosis = true
}

// DoctorToDiagnosisCleared returns if the "DoctorToDiagnosis" edge to the Diagnosis entity was cleared.
func (m *DoctorMutation) DoctorToDiagnosisCleared() bool {
	return m.cleared_DoctorToDiagnosis
}

// RemoveDoctorToDiagnosiIDs removes the "DoctorToDiagnosis" edge to the Diagnosis entity by IDs.
func (m *DoctorMutation) RemoveDoctorToDiagnosiIDs(ids ...int) {
	if m.removed_DoctorToDiagnosis == nil {
		m.removed_DoctorToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DoctorToDiagnosis[ids[i]] = struct{}{}
	}
}

// RemovedDoctorToDiagnosis returns the removed IDs of the "DoctorToDiagnosis" edge to the Diagnosis entity.
func (m *DoctorMutation) RemovedDoctorToDiagnosisIDs() (ids []int) {
	for id := range m.removed_DoctorToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// DoctorToDiagnosisIDs returns the "DoctorToDiagnosis" edge IDs in the mutation.
func (m *DoctorMutation) DoctorToDiagnosisIDs() (ids []int) {
	for id := range m._DoctorToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorToDiagnosis resets all changes to the "DoctorToDiagnosis" edge.
func (m *DoctorMutation) ResetDoctorToDiagnosis() {
	m._DoctorToDiagnosis = nil
	m.cleared_DoctorToDiagnosis = false
	m.removed_DoctorToDiagnosis = nil
}

// AddDoctorToAppointmentResultIDs adds the "DoctorToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *DoctorMutation) AddDoctorToAppointmentResultIDs(ids ...int) {
	if m._DoctorToAppointmentResults == nil {
		m._DoctorToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._DoctorToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearDoctorToAppointmentResults clears the "DoctorToAppointmentResults" edge to the AppointmentResults entity.
func (m *DoctorMutation) ClearDoctorToAppointmentResults() {
	m.cleared_DoctorToAppointmentResults = true
}

// DoctorToAppointmentResultsCleared returns if the "DoctorToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *DoctorMutation) DoctorToAppointmentResultsCleared() bool {
	return m.cleared_DoctorToAppointmentResults
}

// RemoveDoctorToAppointmentResultIDs removes the "DoctorToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *DoctorMutation) RemoveDoctorToAppointmentResultIDs(ids ...int) {
	if m.removed_DoctorToAppointmentResults == nil {
		m.removed_DoctorToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DoctorToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedDoctorToAppointmentResults returns the removed IDs of the "DoctorToAppointmentResults" edge to the AppointmentResults entity.
func (m *DoctorMutation) RemovedDoctorToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_DoctorToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// DoctorToAppointmentResultsIDs returns the "DoctorToAppointmentResults" edge IDs in the mutation.
func (m *DoctorMutation) DoctorToAppointmentResultsIDs() (ids []int) {
	for id := range m._DoctorToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorToAppointmentResults resets all changes to the "DoctorToAppointmentResults" edge.
func (m *DoctorMutation) ResetDoctorToAppointmentResults() {
	m._DoctorToAppointmentResults = nil
	m.cleared_DoctorToAppointmentResults = false
	m.removed_DoctorToAppointmentResults = nil
}

// AddDoctorToMedicalProcedureIDs adds the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity by ids.
func (m *DoctorMutation) AddDoctorToMedicalProcedureIDs(ids ...int) {
	if m._DoctorToMedicalProcedure == nil {
		m._DoctorToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m._DoctorToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// ClearDoctorToMedicalProcedure clears the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *DoctorMutation) ClearDoctorToMedicalProcedure() {
	m.cleared_DoctorToMedicalProcedure = true
}

// DoctorToMedicalProcedureCleared returns if the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity was cleared.
func (m *DoctorMutation) DoctorToMedicalProcedureCleared() bool {
	return m.cleared_DoctorToMedicalProcedure
}

// RemoveDoctorToMedicalProcedureIDs removes the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity by IDs.
func (m *DoctorMutation) RemoveDoctorToMedicalProcedureIDs(ids ...int) {
	if m.removed_DoctorToMedicalProcedure == nil {
		m.removed_DoctorToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DoctorToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// RemovedDoctorToMedicalProcedure returns the removed IDs of the "DoctorToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *DoctorMutation) RemovedDoctorToMedicalProcedureIDs() (ids []int) {
	for id := range m.removed_DoctorToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// DoctorToMedicalProcedureIDs returns the "DoctorToMedicalProcedure" edge IDs in the mutation.
func (m *DoctorMutation) DoctorToMedicalProcedureIDs() (ids []int) {
	for id := range m._DoctorToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorToMedicalProcedure resets all changes to the "DoctorToMedicalProcedure" edge.
func (m *DoctorMutation) ResetDoctorToMedicalProcedure() {
	m._DoctorToMedicalProcedure = nil
	m.cleared_DoctorToMedicalProcedure = false
	m.removed_DoctorToMedicalProcedure = nil
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.doctorName != nil {
		fields = append(fields, doctor.FieldDoctorName)
	}
	if m.doctorUsername != nil {
		fields = append(fields, doctor.FieldDoctorUsername)
	}
	if m.doctorPassword != nil {
		fields = append(fields, doctor.FieldDoctorPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldDoctorName:
		return m.DoctorName()
	case doctor.FieldDoctorUsername:
		return m.DoctorUsername()
	case doctor.FieldDoctorPassword:
		return m.DoctorPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldDoctorName:
		return m.OldDoctorName(ctx)
	case doctor.FieldDoctorUsername:
		return m.OldDoctorUsername(ctx)
	case doctor.FieldDoctorPassword:
		return m.OldDoctorPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldDoctorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorName(v)
		return nil
	case doctor.FieldDoctorUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorUsername(v)
		return nil
	case doctor.FieldDoctorPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldDoctorName:
		m.ResetDoctorName()
		return nil
	case doctor.FieldDoctorUsername:
		m.ResetDoctorUsername()
		return nil
	case doctor.FieldDoctorPassword:
		m.ResetDoctorPassword()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._DoctorToDiagnosis != nil {
		edges = append(edges, doctor.EdgeDoctorToDiagnosis)
	}
	if m._DoctorToAppointmentResults != nil {
		edges = append(edges, doctor.EdgeDoctorToAppointmentResults)
	}
	if m._DoctorToMedicalProcedure != nil {
		edges = append(edges, doctor.EdgeDoctorToMedicalProcedure)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		ids := make([]ent.Value, 0, len(m._DoctorToDiagnosis))
		for id := range m._DoctorToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._DoctorToAppointmentResults))
		for id := range m._DoctorToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m._DoctorToMedicalProcedure))
		for id := range m._DoctorToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_DoctorToDiagnosis != nil {
		edges = append(edges, doctor.EdgeDoctorToDiagnosis)
	}
	if m.removed_DoctorToAppointmentResults != nil {
		edges = append(edges, doctor.EdgeDoctorToAppointmentResults)
	}
	if m.removed_DoctorToMedicalProcedure != nil {
		edges = append(edges, doctor.EdgeDoctorToMedicalProcedure)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		ids := make([]ent.Value, 0, len(m.removed_DoctorToDiagnosis))
		for id := range m.removed_DoctorToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_DoctorToAppointmentResults))
		for id := range m.removed_DoctorToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m.removed_DoctorToMedicalProcedure))
		for id := range m.removed_DoctorToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_DoctorToDiagnosis {
		edges = append(edges, doctor.EdgeDoctorToDiagnosis)
	}
	if m.cleared_DoctorToAppointmentResults {
		edges = append(edges, doctor.EdgeDoctorToAppointmentResults)
	}
	if m.cleared_DoctorToMedicalProcedure {
		edges = append(edges, doctor.EdgeDoctorToMedicalProcedure)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		return m.cleared_DoctorToDiagnosis
	case doctor.EdgeDoctorToAppointmentResults:
		return m.cleared_DoctorToAppointmentResults
	case doctor.EdgeDoctorToMedicalProcedure:
		return m.cleared_DoctorToMedicalProcedure
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeDoctorToDiagnosis:
		m.ResetDoctorToDiagnosis()
		return nil
	case doctor.EdgeDoctorToAppointmentResults:
		m.ResetDoctorToAppointmentResults()
		return nil
	case doctor.EdgeDoctorToMedicalProcedure:
		m.ResetDoctorToMedicalProcedure()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// GenderMutation represents an operation that mutates the Gender nodes in the graph.
type GenderMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	gender                  *string
	clearedFields           map[string]struct{}
	_GenderToPatient        map[int]struct{}
	removed_GenderToPatient map[int]struct{}
	cleared_GenderToPatient bool
	done                    bool
	oldValue                func(context.Context) (*Gender, error)
	predicates              []predicate.Gender
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows management of the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for the Gender entity.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the ID field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGender sets the "gender" field.
func (m *GenderMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *GenderMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Gender entity.
// If the Gender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenderMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *GenderMutation) ResetGender() {
	m.gender = nil
}

// AddGenderToPatientIDs adds the "GenderToPatient" edge to the Patient entity by ids.
func (m *GenderMutation) AddGenderToPatientIDs(ids ...int) {
	if m._GenderToPatient == nil {
		m._GenderToPatient = make(map[int]struct{})
	}
	for i := range ids {
		m._GenderToPatient[ids[i]] = struct{}{}
	}
}

// ClearGenderToPatient clears the "GenderToPatient" edge to the Patient entity.
func (m *GenderMutation) ClearGenderToPatient() {
	m.cleared_GenderToPatient = true
}

// GenderToPatientCleared returns if the "GenderToPatient" edge to the Patient entity was cleared.
func (m *GenderMutation) GenderToPatientCleared() bool {
	return m.cleared_GenderToPatient
}

// RemoveGenderToPatientIDs removes the "GenderToPatient" edge to the Patient entity by IDs.
func (m *GenderMutation) RemoveGenderToPatientIDs(ids ...int) {
	if m.removed_GenderToPatient == nil {
		m.removed_GenderToPatient = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_GenderToPatient[ids[i]] = struct{}{}
	}
}

// RemovedGenderToPatient returns the removed IDs of the "GenderToPatient" edge to the Patient entity.
func (m *GenderMutation) RemovedGenderToPatientIDs() (ids []int) {
	for id := range m.removed_GenderToPatient {
		ids = append(ids, id)
	}
	return
}

// GenderToPatientIDs returns the "GenderToPatient" edge IDs in the mutation.
func (m *GenderMutation) GenderToPatientIDs() (ids []int) {
	for id := range m._GenderToPatient {
		ids = append(ids, id)
	}
	return
}

// ResetGenderToPatient resets all changes to the "GenderToPatient" edge.
func (m *GenderMutation) ResetGenderToPatient() {
	m._GenderToPatient = nil
	m.cleared_GenderToPatient = false
	m.removed_GenderToPatient = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.gender != nil {
		fields = append(fields, gender.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._GenderToPatient != nil {
		edges = append(edges, gender.EdgeGenderToPatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGenderToPatient:
		ids := make([]ent.Value, 0, len(m._GenderToPatient))
		for id := range m._GenderToPatient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_GenderToPatient != nil {
		edges = append(edges, gender.EdgeGenderToPatient)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGenderToPatient:
		ids := make([]ent.Value, 0, len(m.removed_GenderToPatient))
		for id := range m.removed_GenderToPatient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_GenderToPatient {
		edges = append(edges, gender.EdgeGenderToPatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	case gender.EdgeGenderToPatient:
		return m.cleared_GenderToPatient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeGenderToPatient:
		m.ResetGenderToPatient()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// HospitalMutation represents an operation that mutates the Hospital nodes in the graph.
type HospitalMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_HospitalName   *string
	clearedFields   map[string]struct{}
	hospital        map[int]struct{}
	removedhospital map[int]struct{}
	clearedhospital bool
	done            bool
	oldValue        func(context.Context) (*Hospital, error)
	predicates      []predicate.Hospital
}

var _ ent.Mutation = (*HospitalMutation)(nil)

// hospitalOption allows management of the mutation configuration using functional options.
type hospitalOption func(*HospitalMutation)

// newHospitalMutation creates new mutation for the Hospital entity.
func newHospitalMutation(c config, op Op, opts ...hospitalOption) *HospitalMutation {
	m := &HospitalMutation{
		config:        c,
		op:            op,
		typ:           TypeHospital,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHospitalID sets the ID field of the mutation.
func withHospitalID(id int) hospitalOption {
	return func(m *HospitalMutation) {
		var (
			err   error
			once  sync.Once
			value *Hospital
		)
		m.oldValue = func(ctx context.Context) (*Hospital, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hospital.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHospital sets the old Hospital of the mutation.
func withHospital(node *Hospital) hospitalOption {
	return func(m *HospitalMutation) {
		m.oldValue = func(context.Context) (*Hospital, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HospitalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HospitalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HospitalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHospitalName sets the "HospitalName" field.
func (m *HospitalMutation) SetHospitalName(s string) {
	m._HospitalName = &s
}

// HospitalName returns the value of the "HospitalName" field in the mutation.
func (m *HospitalMutation) HospitalName() (r string, exists bool) {
	v := m._HospitalName
	if v == nil {
		return
	}
	return *v, true
}

// OldHospitalName returns the old "HospitalName" field's value of the Hospital entity.
// If the Hospital object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HospitalMutation) OldHospitalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHospitalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHospitalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHospitalName: %w", err)
	}
	return oldValue.HospitalName, nil
}

// ResetHospitalName resets all changes to the "HospitalName" field.
func (m *HospitalMutation) ResetHospitalName() {
	m._HospitalName = nil
}

// AddHospitalIDs adds the "hospital" edge to the RightToTreatment entity by ids.
func (m *HospitalMutation) AddHospitalIDs(ids ...int) {
	if m.hospital == nil {
		m.hospital = make(map[int]struct{})
	}
	for i := range ids {
		m.hospital[ids[i]] = struct{}{}
	}
}

// ClearHospital clears the "hospital" edge to the RightToTreatment entity.
func (m *HospitalMutation) ClearHospital() {
	m.clearedhospital = true
}

// HospitalCleared returns if the "hospital" edge to the RightToTreatment entity was cleared.
func (m *HospitalMutation) HospitalCleared() bool {
	return m.clearedhospital
}

// RemoveHospitalIDs removes the "hospital" edge to the RightToTreatment entity by IDs.
func (m *HospitalMutation) RemoveHospitalIDs(ids ...int) {
	if m.removedhospital == nil {
		m.removedhospital = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhospital[ids[i]] = struct{}{}
	}
}

// RemovedHospital returns the removed IDs of the "hospital" edge to the RightToTreatment entity.
func (m *HospitalMutation) RemovedHospitalIDs() (ids []int) {
	for id := range m.removedhospital {
		ids = append(ids, id)
	}
	return
}

// HospitalIDs returns the "hospital" edge IDs in the mutation.
func (m *HospitalMutation) HospitalIDs() (ids []int) {
	for id := range m.hospital {
		ids = append(ids, id)
	}
	return
}

// ResetHospital resets all changes to the "hospital" edge.
func (m *HospitalMutation) ResetHospital() {
	m.hospital = nil
	m.clearedhospital = false
	m.removedhospital = nil
}

// Op returns the operation name.
func (m *HospitalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hospital).
func (m *HospitalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HospitalMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._HospitalName != nil {
		fields = append(fields, hospital.FieldHospitalName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HospitalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hospital.FieldHospitalName:
		return m.HospitalName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HospitalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hospital.FieldHospitalName:
		return m.OldHospitalName(ctx)
	}
	return nil, fmt.Errorf("unknown Hospital field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HospitalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hospital.FieldHospitalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHospitalName(v)
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HospitalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HospitalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HospitalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HospitalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HospitalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HospitalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hospital nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HospitalMutation) ResetField(name string) error {
	switch name {
	case hospital.FieldHospitalName:
		m.ResetHospitalName()
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HospitalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hospital != nil {
		edges = append(edges, hospital.EdgeHospital)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HospitalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospital:
		ids := make([]ent.Value, 0, len(m.hospital))
		for id := range m.hospital {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HospitalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhospital != nil {
		edges = append(edges, hospital.EdgeHospital)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HospitalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospital:
		ids := make([]ent.Value, 0, len(m.removedhospital))
		for id := range m.removedhospital {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HospitalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhospital {
		edges = append(edges, hospital.EdgeHospital)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HospitalMutation) EdgeCleared(name string) bool {
	switch name {
	case hospital.EdgeHospital:
		return m.clearedhospital
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HospitalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HospitalMutation) ResetEdge(name string) error {
	switch name {
	case hospital.EdgeHospital:
		m.ResetHospital()
		return nil
	}
	return fmt.Errorf("unknown Hospital edge %s", name)
}

// MedicalProcedureMutation represents an operation that mutates the MedicalProcedure nodes in the graph.
type MedicalProcedureMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_Addtime              *time.Time
	clearedFields         map[string]struct{}
	_Patient              *int
	cleared_Patient       bool
	_ProcedureType        *int
	cleared_ProcedureType bool
	_Doctor               *int
	cleared_Doctor        bool
	done                  bool
	oldValue              func(context.Context) (*MedicalProcedure, error)
	predicates            []predicate.MedicalProcedure
}

var _ ent.Mutation = (*MedicalProcedureMutation)(nil)

// medicalprocedureOption allows management of the mutation configuration using functional options.
type medicalprocedureOption func(*MedicalProcedureMutation)

// newMedicalProcedureMutation creates new mutation for the MedicalProcedure entity.
func newMedicalProcedureMutation(c config, op Op, opts ...medicalprocedureOption) *MedicalProcedureMutation {
	m := &MedicalProcedureMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalProcedure,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalProcedureID sets the ID field of the mutation.
func withMedicalProcedureID(id int) medicalprocedureOption {
	return func(m *MedicalProcedureMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalProcedure
		)
		m.oldValue = func(ctx context.Context) (*MedicalProcedure, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalProcedure.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalProcedure sets the old MedicalProcedure of the mutation.
func withMedicalProcedure(node *MedicalProcedure) medicalprocedureOption {
	return func(m *MedicalProcedureMutation) {
		m.oldValue = func(context.Context) (*MedicalProcedure, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalProcedureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalProcedureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MedicalProcedureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddtime sets the "Addtime" field.
func (m *MedicalProcedureMutation) SetAddtime(t time.Time) {
	m._Addtime = &t
}

// Addtime returns the value of the "Addtime" field in the mutation.
func (m *MedicalProcedureMutation) Addtime() (r time.Time, exists bool) {
	v := m._Addtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddtime returns the old "Addtime" field's value of the MedicalProcedure entity.
// If the MedicalProcedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalProcedureMutation) OldAddtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddtime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddtime: %w", err)
	}
	return oldValue.Addtime, nil
}

// ResetAddtime resets all changes to the "Addtime" field.
func (m *MedicalProcedureMutation) ResetAddtime() {
	m._Addtime = nil
}

// SetPatientID sets the "Patient" edge to the Patient entity by id.
func (m *MedicalProcedureMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the "Patient" edge to the Patient entity.
func (m *MedicalProcedureMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the "Patient" edge to the Patient entity was cleared.
func (m *MedicalProcedureMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the "Patient" edge ID in the mutation.
func (m *MedicalProcedureMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the "Patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *MedicalProcedureMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "Patient" edge.
func (m *MedicalProcedureMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// SetProcedureTypeID sets the "ProcedureType" edge to the ProcedureType entity by id.
func (m *MedicalProcedureMutation) SetProcedureTypeID(id int) {
	m._ProcedureType = &id
}

// ClearProcedureType clears the "ProcedureType" edge to the ProcedureType entity.
func (m *MedicalProcedureMutation) ClearProcedureType() {
	m.cleared_ProcedureType = true
}

// ProcedureTypeCleared returns if the "ProcedureType" edge to the ProcedureType entity was cleared.
func (m *MedicalProcedureMutation) ProcedureTypeCleared() bool {
	return m.cleared_ProcedureType
}

// ProcedureTypeID returns the "ProcedureType" edge ID in the mutation.
func (m *MedicalProcedureMutation) ProcedureTypeID() (id int, exists bool) {
	if m._ProcedureType != nil {
		return *m._ProcedureType, true
	}
	return
}

// ProcedureTypeIDs returns the "ProcedureType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProcedureTypeID instead. It exists only for internal usage by the builders.
func (m *MedicalProcedureMutation) ProcedureTypeIDs() (ids []int) {
	if id := m._ProcedureType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProcedureType resets all changes to the "ProcedureType" edge.
func (m *MedicalProcedureMutation) ResetProcedureType() {
	m._ProcedureType = nil
	m.cleared_ProcedureType = false
}

// SetDoctorID sets the "Doctor" edge to the Doctor entity by id.
func (m *MedicalProcedureMutation) SetDoctorID(id int) {
	m._Doctor = &id
}

// ClearDoctor clears the "Doctor" edge to the Doctor entity.
func (m *MedicalProcedureMutation) ClearDoctor() {
	m.cleared_Doctor = true
}

// DoctorCleared returns if the "Doctor" edge to the Doctor entity was cleared.
func (m *MedicalProcedureMutation) DoctorCleared() bool {
	return m.cleared_Doctor
}

// DoctorID returns the "Doctor" edge ID in the mutation.
func (m *MedicalProcedureMutation) DoctorID() (id int, exists bool) {
	if m._Doctor != nil {
		return *m._Doctor, true
	}
	return
}

// DoctorIDs returns the "Doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *MedicalProcedureMutation) DoctorIDs() (ids []int) {
	if id := m._Doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor resets all changes to the "Doctor" edge.
func (m *MedicalProcedureMutation) ResetDoctor() {
	m._Doctor = nil
	m.cleared_Doctor = false
}

// Op returns the operation name.
func (m *MedicalProcedureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MedicalProcedure).
func (m *MedicalProcedureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalProcedureMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Addtime != nil {
		fields = append(fields, medicalprocedure.FieldAddtime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalProcedureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalprocedure.FieldAddtime:
		return m.Addtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalProcedureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalprocedure.FieldAddtime:
		return m.OldAddtime(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalProcedure field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalProcedureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalprocedure.FieldAddtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddtime(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalProcedureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalProcedureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalProcedureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MedicalProcedure numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalProcedureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalProcedureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalProcedureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicalProcedure nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalProcedureMutation) ResetField(name string) error {
	switch name {
	case medicalprocedure.FieldAddtime:
		m.ResetAddtime()
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalProcedureMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Patient != nil {
		edges = append(edges, medicalprocedure.EdgePatient)
	}
	if m._ProcedureType != nil {
		edges = append(edges, medicalprocedure.EdgeProcedureType)
	}
	if m._Doctor != nil {
		edges = append(edges, medicalprocedure.EdgeDoctor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalProcedureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicalprocedure.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	case medicalprocedure.EdgeProcedureType:
		if id := m._ProcedureType; id != nil {
			return []ent.Value{*id}
		}
	case medicalprocedure.EdgeDoctor:
		if id := m._Doctor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalProcedureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalProcedureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalProcedureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Patient {
		edges = append(edges, medicalprocedure.EdgePatient)
	}
	if m.cleared_ProcedureType {
		edges = append(edges, medicalprocedure.EdgeProcedureType)
	}
	if m.cleared_Doctor {
		edges = append(edges, medicalprocedure.EdgeDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalProcedureMutation) EdgeCleared(name string) bool {
	switch name {
	case medicalprocedure.EdgePatient:
		return m.cleared_Patient
	case medicalprocedure.EdgeProcedureType:
		return m.cleared_ProcedureType
	case medicalprocedure.EdgeDoctor:
		return m.cleared_Doctor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalProcedureMutation) ClearEdge(name string) error {
	switch name {
	case medicalprocedure.EdgePatient:
		m.ClearPatient()
		return nil
	case medicalprocedure.EdgeProcedureType:
		m.ClearProcedureType()
		return nil
	case medicalprocedure.EdgeDoctor:
		m.ClearDoctor()
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalProcedureMutation) ResetEdge(name string) error {
	switch name {
	case medicalprocedure.EdgePatient:
		m.ResetPatient()
		return nil
	case medicalprocedure.EdgeProcedureType:
		m.ResetProcedureType()
		return nil
	case medicalprocedure.EdgeDoctor:
		m.ResetDoctor()
		return nil
	}
	return fmt.Errorf("unknown MedicalProcedure edge %s", name)
}

// MedicalRecordMutation represents an operation that mutates the MedicalRecord nodes in the graph.
type MedicalRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	password      *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MedicalRecord, error)
	predicates    []predicate.MedicalRecord
}

var _ ent.Mutation = (*MedicalRecordMutation)(nil)

// medicalrecordOption allows management of the mutation configuration using functional options.
type medicalrecordOption func(*MedicalRecordMutation)

// newMedicalRecordMutation creates new mutation for the MedicalRecord entity.
func newMedicalRecordMutation(c config, op Op, opts ...medicalrecordOption) *MedicalRecordMutation {
	m := &MedicalRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalRecordID sets the ID field of the mutation.
func withMedicalRecordID(id int) medicalrecordOption {
	return func(m *MedicalRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalRecord
		)
		m.oldValue = func(ctx context.Context) (*MedicalRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalRecord sets the old MedicalRecord of the mutation.
func withMedicalRecord(node *MedicalRecord) medicalrecordOption {
	return func(m *MedicalRecordMutation) {
		m.oldValue = func(context.Context) (*MedicalRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MedicalRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *MedicalRecordMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MedicalRecordMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MedicalRecord entity.
// If the MedicalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalRecordMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MedicalRecordMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *MedicalRecordMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MedicalRecordMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the MedicalRecord entity.
// If the MedicalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalRecordMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MedicalRecordMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *MedicalRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MedicalRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MedicalRecord entity.
// If the MedicalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MedicalRecordMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *MedicalRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MedicalRecord).
func (m *MedicalRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalRecordMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, medicalrecord.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, medicalrecord.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, medicalrecord.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalrecord.FieldEmail:
		return m.Email()
	case medicalrecord.FieldPassword:
		return m.Password()
	case medicalrecord.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalrecord.FieldEmail:
		return m.OldEmail(ctx)
	case medicalrecord.FieldPassword:
		return m.OldPassword(ctx)
	case medicalrecord.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalrecord.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case medicalrecord.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case medicalrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MedicalRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicalRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalRecordMutation) ResetField(name string) error {
	switch name {
	case medicalrecord.FieldEmail:
		m.ResetEmail()
		return nil
	case medicalrecord.FieldPassword:
		m.ResetPassword()
		return nil
	case medicalrecord.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown MedicalRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MedicalRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MedicalRecord edge %s", name)
}

// NurseMutation represents an operation that mutates the Nurse nodes in the graph.
type NurseMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	nurseName                         *string
	nurseUsername                     *string
	nursePassword                     *string
	clearedFields                     map[string]struct{}
	nurseToTriageResult               map[int]struct{}
	removednurseToTriageResult        map[int]struct{}
	clearednurseToTriageResult        bool
	_NurseToAppointmentResults        map[int]struct{}
	removed_NurseToAppointmentResults map[int]struct{}
	cleared_NurseToAppointmentResults bool
	done                              bool
	oldValue                          func(context.Context) (*Nurse, error)
	predicates                        []predicate.Nurse
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows management of the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for the Nurse entity.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the ID field of the mutation.
func withNurseID(id int) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NurseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNurseName sets the "nurseName" field.
func (m *NurseMutation) SetNurseName(s string) {
	m.nurseName = &s
}

// NurseName returns the value of the "nurseName" field in the mutation.
func (m *NurseMutation) NurseName() (r string, exists bool) {
	v := m.nurseName
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseName returns the old "nurseName" field's value of the Nurse entity.
// If the Nurse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseMutation) OldNurseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseName: %w", err)
	}
	return oldValue.NurseName, nil
}

// ResetNurseName resets all changes to the "nurseName" field.
func (m *NurseMutation) ResetNurseName() {
	m.nurseName = nil
}

// SetNurseUsername sets the "nurseUsername" field.
func (m *NurseMutation) SetNurseUsername(s string) {
	m.nurseUsername = &s
}

// NurseUsername returns the value of the "nurseUsername" field in the mutation.
func (m *NurseMutation) NurseUsername() (r string, exists bool) {
	v := m.nurseUsername
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseUsername returns the old "nurseUsername" field's value of the Nurse entity.
// If the Nurse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseMutation) OldNurseUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseUsername: %w", err)
	}
	return oldValue.NurseUsername, nil
}

// ResetNurseUsername resets all changes to the "nurseUsername" field.
func (m *NurseMutation) ResetNurseUsername() {
	m.nurseUsername = nil
}

// SetNursePassword sets the "nursePassword" field.
func (m *NurseMutation) SetNursePassword(s string) {
	m.nursePassword = &s
}

// NursePassword returns the value of the "nursePassword" field in the mutation.
func (m *NurseMutation) NursePassword() (r string, exists bool) {
	v := m.nursePassword
	if v == nil {
		return
	}
	return *v, true
}

// OldNursePassword returns the old "nursePassword" field's value of the Nurse entity.
// If the Nurse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseMutation) OldNursePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNursePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNursePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNursePassword: %w", err)
	}
	return oldValue.NursePassword, nil
}

// ResetNursePassword resets all changes to the "nursePassword" field.
func (m *NurseMutation) ResetNursePassword() {
	m.nursePassword = nil
}

// AddNurseToTriageResultIDs adds the "nurseToTriageResult" edge to the TriageResult entity by ids.
func (m *NurseMutation) AddNurseToTriageResultIDs(ids ...int) {
	if m.nurseToTriageResult == nil {
		m.nurseToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.nurseToTriageResult[ids[i]] = struct{}{}
	}
}

// ClearNurseToTriageResult clears the "nurseToTriageResult" edge to the TriageResult entity.
func (m *NurseMutation) ClearNurseToTriageResult() {
	m.clearednurseToTriageResult = true
}

// NurseToTriageResultCleared returns if the "nurseToTriageResult" edge to the TriageResult entity was cleared.
func (m *NurseMutation) NurseToTriageResultCleared() bool {
	return m.clearednurseToTriageResult
}

// RemoveNurseToTriageResultIDs removes the "nurseToTriageResult" edge to the TriageResult entity by IDs.
func (m *NurseMutation) RemoveNurseToTriageResultIDs(ids ...int) {
	if m.removednurseToTriageResult == nil {
		m.removednurseToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removednurseToTriageResult[ids[i]] = struct{}{}
	}
}

// RemovedNurseToTriageResult returns the removed IDs of the "nurseToTriageResult" edge to the TriageResult entity.
func (m *NurseMutation) RemovedNurseToTriageResultIDs() (ids []int) {
	for id := range m.removednurseToTriageResult {
		ids = append(ids, id)
	}
	return
}

// NurseToTriageResultIDs returns the "nurseToTriageResult" edge IDs in the mutation.
func (m *NurseMutation) NurseToTriageResultIDs() (ids []int) {
	for id := range m.nurseToTriageResult {
		ids = append(ids, id)
	}
	return
}

// ResetNurseToTriageResult resets all changes to the "nurseToTriageResult" edge.
func (m *NurseMutation) ResetNurseToTriageResult() {
	m.nurseToTriageResult = nil
	m.clearednurseToTriageResult = false
	m.removednurseToTriageResult = nil
}

// AddNurseToAppointmentResultIDs adds the "NurseToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *NurseMutation) AddNurseToAppointmentResultIDs(ids ...int) {
	if m._NurseToAppointmentResults == nil {
		m._NurseToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._NurseToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearNurseToAppointmentResults clears the "NurseToAppointmentResults" edge to the AppointmentResults entity.
func (m *NurseMutation) ClearNurseToAppointmentResults() {
	m.cleared_NurseToAppointmentResults = true
}

// NurseToAppointmentResultsCleared returns if the "NurseToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *NurseMutation) NurseToAppointmentResultsCleared() bool {
	return m.cleared_NurseToAppointmentResults
}

// RemoveNurseToAppointmentResultIDs removes the "NurseToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *NurseMutation) RemoveNurseToAppointmentResultIDs(ids ...int) {
	if m.removed_NurseToAppointmentResults == nil {
		m.removed_NurseToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_NurseToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedNurseToAppointmentResults returns the removed IDs of the "NurseToAppointmentResults" edge to the AppointmentResults entity.
func (m *NurseMutation) RemovedNurseToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_NurseToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// NurseToAppointmentResultsIDs returns the "NurseToAppointmentResults" edge IDs in the mutation.
func (m *NurseMutation) NurseToAppointmentResultsIDs() (ids []int) {
	for id := range m._NurseToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetNurseToAppointmentResults resets all changes to the "NurseToAppointmentResults" edge.
func (m *NurseMutation) ResetNurseToAppointmentResults() {
	m._NurseToAppointmentResults = nil
	m.cleared_NurseToAppointmentResults = false
	m.removed_NurseToAppointmentResults = nil
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.nurseName != nil {
		fields = append(fields, nurse.FieldNurseName)
	}
	if m.nurseUsername != nil {
		fields = append(fields, nurse.FieldNurseUsername)
	}
	if m.nursePassword != nil {
		fields = append(fields, nurse.FieldNursePassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldNurseName:
		return m.NurseName()
	case nurse.FieldNurseUsername:
		return m.NurseUsername()
	case nurse.FieldNursePassword:
		return m.NursePassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldNurseName:
		return m.OldNurseName(ctx)
	case nurse.FieldNurseUsername:
		return m.OldNurseUsername(ctx)
	case nurse.FieldNursePassword:
		return m.OldNursePassword(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldNurseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseName(v)
		return nil
	case nurse.FieldNurseUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseUsername(v)
		return nil
	case nurse.FieldNursePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNursePassword(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldNurseName:
		m.ResetNurseName()
		return nil
	case nurse.FieldNurseUsername:
		m.ResetNurseUsername()
		return nil
	case nurse.FieldNursePassword:
		m.ResetNursePassword()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nurseToTriageResult != nil {
		edges = append(edges, nurse.EdgeNurseToTriageResult)
	}
	if m._NurseToAppointmentResults != nil {
		edges = append(edges, nurse.EdgeNurseToAppointmentResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeNurseToTriageResult:
		ids := make([]ent.Value, 0, len(m.nurseToTriageResult))
		for id := range m.nurseToTriageResult {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNurseToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._NurseToAppointmentResults))
		for id := range m._NurseToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednurseToTriageResult != nil {
		edges = append(edges, nurse.EdgeNurseToTriageResult)
	}
	if m.removed_NurseToAppointmentResults != nil {
		edges = append(edges, nurse.EdgeNurseToAppointmentResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeNurseToTriageResult:
		ids := make([]ent.Value, 0, len(m.removednurseToTriageResult))
		for id := range m.removednurseToTriageResult {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNurseToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_NurseToAppointmentResults))
		for id := range m.removed_NurseToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednurseToTriageResult {
		edges = append(edges, nurse.EdgeNurseToTriageResult)
	}
	if m.cleared_NurseToAppointmentResults {
		edges = append(edges, nurse.EdgeNurseToAppointmentResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	case nurse.EdgeNurseToTriageResult:
		return m.clearednurseToTriageResult
	case nurse.EdgeNurseToAppointmentResults:
		return m.cleared_NurseToAppointmentResults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeNurseToTriageResult:
		m.ResetNurseToTriageResult()
		return nil
	case nurse.EdgeNurseToAppointmentResults:
		m.ResetNurseToAppointmentResults()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	personalID                          *int
	addpersonalID                       *int
	patientName                         *string
	age                                 *int
	addage                              *int
	hospitalNumber                      *string
	drugAllergy                         *string
	added_time                          *time.Time
	clearedFields                       map[string]struct{}
	_Prefix                             *int
	cleared_Prefix                      bool
	_Gender                             *int
	cleared_Gender                      bool
	_Bloodtype                          *int
	cleared_Bloodtype                   bool
	patientToTriageResult               map[int]struct{}
	removedpatientToTriageResult        map[int]struct{}
	clearedpatientToTriageResult        bool
	_PatientToAppointmentResults        map[int]struct{}
	removed_PatientToAppointmentResults map[int]struct{}
	cleared_PatientToAppointmentResults bool
	_PatientToMedicalProcedure          map[int]struct{}
	removed_PatientToMedicalProcedure   map[int]struct{}
	cleared_PatientToMedicalProcedure   bool
	_PatientToRightToTreatment          map[int]struct{}
	removed_PatientToRightToTreatment   map[int]struct{}
	cleared_PatientToRightToTreatment   bool
	_PatientToDiagnosis                 map[int]struct{}
	removed_PatientToDiagnosis          map[int]struct{}
	cleared_PatientToDiagnosis          bool
	done                                bool
	oldValue                            func(context.Context) (*Patient, error)
	predicates                          []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id int) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PatientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPersonalID sets the "personalID" field.
func (m *PatientMutation) SetPersonalID(i int) {
	m.personalID = &i
	m.addpersonalID = nil
}

// PersonalID returns the value of the "personalID" field in the mutation.
func (m *PatientMutation) PersonalID() (r int, exists bool) {
	v := m.personalID
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalID returns the old "personalID" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPersonalID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalID: %w", err)
	}
	return oldValue.PersonalID, nil
}

// AddPersonalID adds i to the "personalID" field.
func (m *PatientMutation) AddPersonalID(i int) {
	if m.addpersonalID != nil {
		*m.addpersonalID += i
	} else {
		m.addpersonalID = &i
	}
}

// AddedPersonalID returns the value that was added to the "personalID" field in this mutation.
func (m *PatientMutation) AddedPersonalID() (r int, exists bool) {
	v := m.addpersonalID
	if v == nil {
		return
	}
	return *v, true
}

// ResetPersonalID resets all changes to the "personalID" field.
func (m *PatientMutation) ResetPersonalID() {
	m.personalID = nil
	m.addpersonalID = nil
}

// SetPatientName sets the "patientName" field.
func (m *PatientMutation) SetPatientName(s string) {
	m.patientName = &s
}

// PatientName returns the value of the "patientName" field in the mutation.
func (m *PatientMutation) PatientName() (r string, exists bool) {
	v := m.patientName
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientName returns the old "patientName" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientName: %w", err)
	}
	return oldValue.PatientName, nil
}

// ResetPatientName resets all changes to the "patientName" field.
func (m *PatientMutation) ResetPatientName() {
	m.patientName = nil
}

// SetAge sets the "age" field.
func (m *PatientMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *PatientMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *PatientMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *PatientMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *PatientMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetHospitalNumber sets the "hospitalNumber" field.
func (m *PatientMutation) SetHospitalNumber(s string) {
	m.hospitalNumber = &s
}

// HospitalNumber returns the value of the "hospitalNumber" field in the mutation.
func (m *PatientMutation) HospitalNumber() (r string, exists bool) {
	v := m.hospitalNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldHospitalNumber returns the old "hospitalNumber" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldHospitalNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHospitalNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHospitalNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHospitalNumber: %w", err)
	}
	return oldValue.HospitalNumber, nil
}

// ResetHospitalNumber resets all changes to the "hospitalNumber" field.
func (m *PatientMutation) ResetHospitalNumber() {
	m.hospitalNumber = nil
}

// SetDrugAllergy sets the "drugAllergy" field.
func (m *PatientMutation) SetDrugAllergy(s string) {
	m.drugAllergy = &s
}

// DrugAllergy returns the value of the "drugAllergy" field in the mutation.
func (m *PatientMutation) DrugAllergy() (r string, exists bool) {
	v := m.drugAllergy
	if v == nil {
		return
	}
	return *v, true
}

// OldDrugAllergy returns the old "drugAllergy" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldDrugAllergy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDrugAllergy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDrugAllergy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrugAllergy: %w", err)
	}
	return oldValue.DrugAllergy, nil
}

// ResetDrugAllergy resets all changes to the "drugAllergy" field.
func (m *PatientMutation) ResetDrugAllergy() {
	m.drugAllergy = nil
}

// SetAddedTime sets the "added_time" field.
func (m *PatientMutation) SetAddedTime(t time.Time) {
	m.added_time = &t
}

// AddedTime returns the value of the "added_time" field in the mutation.
func (m *PatientMutation) AddedTime() (r time.Time, exists bool) {
	v := m.added_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime returns the old "added_time" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldAddedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime: %w", err)
	}
	return oldValue.AddedTime, nil
}

// ResetAddedTime resets all changes to the "added_time" field.
func (m *PatientMutation) ResetAddedTime() {
	m.added_time = nil
}

// SetPrefixID sets the "Prefix" edge to the Prefix entity by id.
func (m *PatientMutation) SetPrefixID(id int) {
	m._Prefix = &id
}

// ClearPrefix clears the "Prefix" edge to the Prefix entity.
func (m *PatientMutation) ClearPrefix() {
	m.cleared_Prefix = true
}

// PrefixCleared returns if the "Prefix" edge to the Prefix entity was cleared.
func (m *PatientMutation) PrefixCleared() bool {
	return m.cleared_Prefix
}

// PrefixID returns the "Prefix" edge ID in the mutation.
func (m *PatientMutation) PrefixID() (id int, exists bool) {
	if m._Prefix != nil {
		return *m._Prefix, true
	}
	return
}

// PrefixIDs returns the "Prefix" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrefixID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) PrefixIDs() (ids []int) {
	if id := m._Prefix; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrefix resets all changes to the "Prefix" edge.
func (m *PatientMutation) ResetPrefix() {
	m._Prefix = nil
	m.cleared_Prefix = false
}

// SetGenderID sets the "Gender" edge to the Gender entity by id.
func (m *PatientMutation) SetGenderID(id int) {
	m._Gender = &id
}

// ClearGender clears the "Gender" edge to the Gender entity.
func (m *PatientMutation) ClearGender() {
	m.cleared_Gender = true
}

// GenderCleared returns if the "Gender" edge to the Gender entity was cleared.
func (m *PatientMutation) GenderCleared() bool {
	return m.cleared_Gender
}

// GenderID returns the "Gender" edge ID in the mutation.
func (m *PatientMutation) GenderID() (id int, exists bool) {
	if m._Gender != nil {
		return *m._Gender, true
	}
	return
}

// GenderIDs returns the "Gender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenderID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) GenderIDs() (ids []int) {
	if id := m._Gender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGender resets all changes to the "Gender" edge.
func (m *PatientMutation) ResetGender() {
	m._Gender = nil
	m.cleared_Gender = false
}

// SetBloodtypeID sets the "Bloodtype" edge to the BloodType entity by id.
func (m *PatientMutation) SetBloodtypeID(id int) {
	m._Bloodtype = &id
}

// ClearBloodtype clears the "Bloodtype" edge to the BloodType entity.
func (m *PatientMutation) ClearBloodtype() {
	m.cleared_Bloodtype = true
}

// BloodtypeCleared returns if the "Bloodtype" edge to the BloodType entity was cleared.
func (m *PatientMutation) BloodtypeCleared() bool {
	return m.cleared_Bloodtype
}

// BloodtypeID returns the "Bloodtype" edge ID in the mutation.
func (m *PatientMutation) BloodtypeID() (id int, exists bool) {
	if m._Bloodtype != nil {
		return *m._Bloodtype, true
	}
	return
}

// BloodtypeIDs returns the "Bloodtype" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BloodtypeID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) BloodtypeIDs() (ids []int) {
	if id := m._Bloodtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBloodtype resets all changes to the "Bloodtype" edge.
func (m *PatientMutation) ResetBloodtype() {
	m._Bloodtype = nil
	m.cleared_Bloodtype = false
}

// AddPatientToTriageResultIDs adds the "patientToTriageResult" edge to the TriageResult entity by ids.
func (m *PatientMutation) AddPatientToTriageResultIDs(ids ...int) {
	if m.patientToTriageResult == nil {
		m.patientToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.patientToTriageResult[ids[i]] = struct{}{}
	}
}

// ClearPatientToTriageResult clears the "patientToTriageResult" edge to the TriageResult entity.
func (m *PatientMutation) ClearPatientToTriageResult() {
	m.clearedpatientToTriageResult = true
}

// PatientToTriageResultCleared returns if the "patientToTriageResult" edge to the TriageResult entity was cleared.
func (m *PatientMutation) PatientToTriageResultCleared() bool {
	return m.clearedpatientToTriageResult
}

// RemovePatientToTriageResultIDs removes the "patientToTriageResult" edge to the TriageResult entity by IDs.
func (m *PatientMutation) RemovePatientToTriageResultIDs(ids ...int) {
	if m.removedpatientToTriageResult == nil {
		m.removedpatientToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatientToTriageResult[ids[i]] = struct{}{}
	}
}

// RemovedPatientToTriageResult returns the removed IDs of the "patientToTriageResult" edge to the TriageResult entity.
func (m *PatientMutation) RemovedPatientToTriageResultIDs() (ids []int) {
	for id := range m.removedpatientToTriageResult {
		ids = append(ids, id)
	}
	return
}

// PatientToTriageResultIDs returns the "patientToTriageResult" edge IDs in the mutation.
func (m *PatientMutation) PatientToTriageResultIDs() (ids []int) {
	for id := range m.patientToTriageResult {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToTriageResult resets all changes to the "patientToTriageResult" edge.
func (m *PatientMutation) ResetPatientToTriageResult() {
	m.patientToTriageResult = nil
	m.clearedpatientToTriageResult = false
	m.removedpatientToTriageResult = nil
}

// AddPatientToAppointmentResultIDs adds the "PatientToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *PatientMutation) AddPatientToAppointmentResultIDs(ids ...int) {
	if m._PatientToAppointmentResults == nil {
		m._PatientToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearPatientToAppointmentResults clears the "PatientToAppointmentResults" edge to the AppointmentResults entity.
func (m *PatientMutation) ClearPatientToAppointmentResults() {
	m.cleared_PatientToAppointmentResults = true
}

// PatientToAppointmentResultsCleared returns if the "PatientToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *PatientMutation) PatientToAppointmentResultsCleared() bool {
	return m.cleared_PatientToAppointmentResults
}

// RemovePatientToAppointmentResultIDs removes the "PatientToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *PatientMutation) RemovePatientToAppointmentResultIDs(ids ...int) {
	if m.removed_PatientToAppointmentResults == nil {
		m.removed_PatientToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedPatientToAppointmentResults returns the removed IDs of the "PatientToAppointmentResults" edge to the AppointmentResults entity.
func (m *PatientMutation) RemovedPatientToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_PatientToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// PatientToAppointmentResultsIDs returns the "PatientToAppointmentResults" edge IDs in the mutation.
func (m *PatientMutation) PatientToAppointmentResultsIDs() (ids []int) {
	for id := range m._PatientToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToAppointmentResults resets all changes to the "PatientToAppointmentResults" edge.
func (m *PatientMutation) ResetPatientToAppointmentResults() {
	m._PatientToAppointmentResults = nil
	m.cleared_PatientToAppointmentResults = false
	m.removed_PatientToAppointmentResults = nil
}

// AddPatientToMedicalProcedureIDs adds the "PatientToMedicalProcedure" edge to the MedicalProcedure entity by ids.
func (m *PatientMutation) AddPatientToMedicalProcedureIDs(ids ...int) {
	if m._PatientToMedicalProcedure == nil {
		m._PatientToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// ClearPatientToMedicalProcedure clears the "PatientToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *PatientMutation) ClearPatientToMedicalProcedure() {
	m.cleared_PatientToMedicalProcedure = true
}

// PatientToMedicalProcedureCleared returns if the "PatientToMedicalProcedure" edge to the MedicalProcedure entity was cleared.
func (m *PatientMutation) PatientToMedicalProcedureCleared() bool {
	return m.cleared_PatientToMedicalProcedure
}

// RemovePatientToMedicalProcedureIDs removes the "PatientToMedicalProcedure" edge to the MedicalProcedure entity by IDs.
func (m *PatientMutation) RemovePatientToMedicalProcedureIDs(ids ...int) {
	if m.removed_PatientToMedicalProcedure == nil {
		m.removed_PatientToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// RemovedPatientToMedicalProcedure returns the removed IDs of the "PatientToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *PatientMutation) RemovedPatientToMedicalProcedureIDs() (ids []int) {
	for id := range m.removed_PatientToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// PatientToMedicalProcedureIDs returns the "PatientToMedicalProcedure" edge IDs in the mutation.
func (m *PatientMutation) PatientToMedicalProcedureIDs() (ids []int) {
	for id := range m._PatientToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToMedicalProcedure resets all changes to the "PatientToMedicalProcedure" edge.
func (m *PatientMutation) ResetPatientToMedicalProcedure() {
	m._PatientToMedicalProcedure = nil
	m.cleared_PatientToMedicalProcedure = false
	m.removed_PatientToMedicalProcedure = nil
}

// AddPatientToRightToTreatmentIDs adds the "PatientToRightToTreatment" edge to the RightToTreatment entity by ids.
func (m *PatientMutation) AddPatientToRightToTreatmentIDs(ids ...int) {
	if m._PatientToRightToTreatment == nil {
		m._PatientToRightToTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToRightToTreatment[ids[i]] = struct{}{}
	}
}

// ClearPatientToRightToTreatment clears the "PatientToRightToTreatment" edge to the RightToTreatment entity.
func (m *PatientMutation) ClearPatientToRightToTreatment() {
	m.cleared_PatientToRightToTreatment = true
}

// PatientToRightToTreatmentCleared returns if the "PatientToRightToTreatment" edge to the RightToTreatment entity was cleared.
func (m *PatientMutation) PatientToRightToTreatmentCleared() bool {
	return m.cleared_PatientToRightToTreatment
}

// RemovePatientToRightToTreatmentIDs removes the "PatientToRightToTreatment" edge to the RightToTreatment entity by IDs.
func (m *PatientMutation) RemovePatientToRightToTreatmentIDs(ids ...int) {
	if m.removed_PatientToRightToTreatment == nil {
		m.removed_PatientToRightToTreatment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToRightToTreatment[ids[i]] = struct{}{}
	}
}

// RemovedPatientToRightToTreatment returns the removed IDs of the "PatientToRightToTreatment" edge to the RightToTreatment entity.
func (m *PatientMutation) RemovedPatientToRightToTreatmentIDs() (ids []int) {
	for id := range m.removed_PatientToRightToTreatment {
		ids = append(ids, id)
	}
	return
}

// PatientToRightToTreatmentIDs returns the "PatientToRightToTreatment" edge IDs in the mutation.
func (m *PatientMutation) PatientToRightToTreatmentIDs() (ids []int) {
	for id := range m._PatientToRightToTreatment {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToRightToTreatment resets all changes to the "PatientToRightToTreatment" edge.
func (m *PatientMutation) ResetPatientToRightToTreatment() {
	m._PatientToRightToTreatment = nil
	m.cleared_PatientToRightToTreatment = false
	m.removed_PatientToRightToTreatment = nil
}

// AddPatientToDiagnosiIDs adds the "PatientToDiagnosis" edge to the Diagnosis entity by ids.
func (m *PatientMutation) AddPatientToDiagnosiIDs(ids ...int) {
	if m._PatientToDiagnosis == nil {
		m._PatientToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m._PatientToDiagnosis[ids[i]] = struct{}{}
	}
}

// ClearPatientToDiagnosis clears the "PatientToDiagnosis" edge to the Diagnosis entity.
func (m *PatientMutation) ClearPatientToDiagnosis() {
	m.cleared_PatientToDiagnosis = true
}

// PatientToDiagnosisCleared returns if the "PatientToDiagnosis" edge to the Diagnosis entity was cleared.
func (m *PatientMutation) PatientToDiagnosisCleared() bool {
	return m.cleared_PatientToDiagnosis
}

// RemovePatientToDiagnosiIDs removes the "PatientToDiagnosis" edge to the Diagnosis entity by IDs.
func (m *PatientMutation) RemovePatientToDiagnosiIDs(ids ...int) {
	if m.removed_PatientToDiagnosis == nil {
		m.removed_PatientToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PatientToDiagnosis[ids[i]] = struct{}{}
	}
}

// RemovedPatientToDiagnosis returns the removed IDs of the "PatientToDiagnosis" edge to the Diagnosis entity.
func (m *PatientMutation) RemovedPatientToDiagnosisIDs() (ids []int) {
	for id := range m.removed_PatientToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// PatientToDiagnosisIDs returns the "PatientToDiagnosis" edge IDs in the mutation.
func (m *PatientMutation) PatientToDiagnosisIDs() (ids []int) {
	for id := range m._PatientToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// ResetPatientToDiagnosis resets all changes to the "PatientToDiagnosis" edge.
func (m *PatientMutation) ResetPatientToDiagnosis() {
	m._PatientToDiagnosis = nil
	m.cleared_PatientToDiagnosis = false
	m.removed_PatientToDiagnosis = nil
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.personalID != nil {
		fields = append(fields, patient.FieldPersonalID)
	}
	if m.patientName != nil {
		fields = append(fields, patient.FieldPatientName)
	}
	if m.age != nil {
		fields = append(fields, patient.FieldAge)
	}
	if m.hospitalNumber != nil {
		fields = append(fields, patient.FieldHospitalNumber)
	}
	if m.drugAllergy != nil {
		fields = append(fields, patient.FieldDrugAllergy)
	}
	if m.added_time != nil {
		fields = append(fields, patient.FieldAddedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPersonalID:
		return m.PersonalID()
	case patient.FieldPatientName:
		return m.PatientName()
	case patient.FieldAge:
		return m.Age()
	case patient.FieldHospitalNumber:
		return m.HospitalNumber()
	case patient.FieldDrugAllergy:
		return m.DrugAllergy()
	case patient.FieldAddedTime:
		return m.AddedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldPersonalID:
		return m.OldPersonalID(ctx)
	case patient.FieldPatientName:
		return m.OldPatientName(ctx)
	case patient.FieldAge:
		return m.OldAge(ctx)
	case patient.FieldHospitalNumber:
		return m.OldHospitalNumber(ctx)
	case patient.FieldDrugAllergy:
		return m.OldDrugAllergy(ctx)
	case patient.FieldAddedTime:
		return m.OldAddedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPersonalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalID(v)
		return nil
	case patient.FieldPatientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientName(v)
		return nil
	case patient.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case patient.FieldHospitalNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHospitalNumber(v)
		return nil
	case patient.FieldDrugAllergy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrugAllergy(v)
		return nil
	case patient.FieldAddedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.addpersonalID != nil {
		fields = append(fields, patient.FieldPersonalID)
	}
	if m.addage != nil {
		fields = append(fields, patient.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPersonalID:
		return m.AddedPersonalID()
	case patient.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPersonalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPersonalID(v)
		return nil
	case patient.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldPersonalID:
		m.ResetPersonalID()
		return nil
	case patient.FieldPatientName:
		m.ResetPatientName()
		return nil
	case patient.FieldAge:
		m.ResetAge()
		return nil
	case patient.FieldHospitalNumber:
		m.ResetHospitalNumber()
		return nil
	case patient.FieldDrugAllergy:
		m.ResetDrugAllergy()
		return nil
	case patient.FieldAddedTime:
		m.ResetAddedTime()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m._Prefix != nil {
		edges = append(edges, patient.EdgePrefix)
	}
	if m._Gender != nil {
		edges = append(edges, patient.EdgeGender)
	}
	if m._Bloodtype != nil {
		edges = append(edges, patient.EdgeBloodtype)
	}
	if m.patientToTriageResult != nil {
		edges = append(edges, patient.EdgePatientToTriageResult)
	}
	if m._PatientToAppointmentResults != nil {
		edges = append(edges, patient.EdgePatientToAppointmentResults)
	}
	if m._PatientToMedicalProcedure != nil {
		edges = append(edges, patient.EdgePatientToMedicalProcedure)
	}
	if m._PatientToRightToTreatment != nil {
		edges = append(edges, patient.EdgePatientToRightToTreatment)
	}
	if m._PatientToDiagnosis != nil {
		edges = append(edges, patient.EdgePatientToDiagnosis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePrefix:
		if id := m._Prefix; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeGender:
		if id := m._Gender; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeBloodtype:
		if id := m._Bloodtype; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgePatientToTriageResult:
		ids := make([]ent.Value, 0, len(m.patientToTriageResult))
		for id := range m.patientToTriageResult {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._PatientToAppointmentResults))
		for id := range m._PatientToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m._PatientToMedicalProcedure))
		for id := range m._PatientToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToRightToTreatment:
		ids := make([]ent.Value, 0, len(m._PatientToRightToTreatment))
		for id := range m._PatientToRightToTreatment {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToDiagnosis:
		ids := make([]ent.Value, 0, len(m._PatientToDiagnosis))
		for id := range m._PatientToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedpatientToTriageResult != nil {
		edges = append(edges, patient.EdgePatientToTriageResult)
	}
	if m.removed_PatientToAppointmentResults != nil {
		edges = append(edges, patient.EdgePatientToAppointmentResults)
	}
	if m.removed_PatientToMedicalProcedure != nil {
		edges = append(edges, patient.EdgePatientToMedicalProcedure)
	}
	if m.removed_PatientToRightToTreatment != nil {
		edges = append(edges, patient.EdgePatientToRightToTreatment)
	}
	if m.removed_PatientToDiagnosis != nil {
		edges = append(edges, patient.EdgePatientToDiagnosis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePatientToTriageResult:
		ids := make([]ent.Value, 0, len(m.removedpatientToTriageResult))
		for id := range m.removedpatientToTriageResult {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_PatientToAppointmentResults))
		for id := range m.removed_PatientToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m.removed_PatientToMedicalProcedure))
		for id := range m.removed_PatientToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToRightToTreatment:
		ids := make([]ent.Value, 0, len(m.removed_PatientToRightToTreatment))
		for id := range m.removed_PatientToRightToTreatment {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientToDiagnosis:
		ids := make([]ent.Value, 0, len(m.removed_PatientToDiagnosis))
		for id := range m.removed_PatientToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleared_Prefix {
		edges = append(edges, patient.EdgePrefix)
	}
	if m.cleared_Gender {
		edges = append(edges, patient.EdgeGender)
	}
	if m.cleared_Bloodtype {
		edges = append(edges, patient.EdgeBloodtype)
	}
	if m.clearedpatientToTriageResult {
		edges = append(edges, patient.EdgePatientToTriageResult)
	}
	if m.cleared_PatientToAppointmentResults {
		edges = append(edges, patient.EdgePatientToAppointmentResults)
	}
	if m.cleared_PatientToMedicalProcedure {
		edges = append(edges, patient.EdgePatientToMedicalProcedure)
	}
	if m.cleared_PatientToRightToTreatment {
		edges = append(edges, patient.EdgePatientToRightToTreatment)
	}
	if m.cleared_PatientToDiagnosis {
		edges = append(edges, patient.EdgePatientToDiagnosis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgePrefix:
		return m.cleared_Prefix
	case patient.EdgeGender:
		return m.cleared_Gender
	case patient.EdgeBloodtype:
		return m.cleared_Bloodtype
	case patient.EdgePatientToTriageResult:
		return m.clearedpatientToTriageResult
	case patient.EdgePatientToAppointmentResults:
		return m.cleared_PatientToAppointmentResults
	case patient.EdgePatientToMedicalProcedure:
		return m.cleared_PatientToMedicalProcedure
	case patient.EdgePatientToRightToTreatment:
		return m.cleared_PatientToRightToTreatment
	case patient.EdgePatientToDiagnosis:
		return m.cleared_PatientToDiagnosis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	case patient.EdgePrefix:
		m.ClearPrefix()
		return nil
	case patient.EdgeGender:
		m.ClearGender()
		return nil
	case patient.EdgeBloodtype:
		m.ClearBloodtype()
		return nil
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgePrefix:
		m.ResetPrefix()
		return nil
	case patient.EdgeGender:
		m.ResetGender()
		return nil
	case patient.EdgeBloodtype:
		m.ResetBloodtype()
		return nil
	case patient.EdgePatientToTriageResult:
		m.ResetPatientToTriageResult()
		return nil
	case patient.EdgePatientToAppointmentResults:
		m.ResetPatientToAppointmentResults()
		return nil
	case patient.EdgePatientToMedicalProcedure:
		m.ResetPatientToMedicalProcedure()
		return nil
	case patient.EdgePatientToRightToTreatment:
		m.ResetPatientToRightToTreatment()
		return nil
	case patient.EdgePatientToDiagnosis:
		m.ResetPatientToDiagnosis()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PrefixMutation represents an operation that mutates the Prefix nodes in the graph.
type PrefixMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	prefix                  *string
	clearedFields           map[string]struct{}
	_PrefixToPatient        map[int]struct{}
	removed_PrefixToPatient map[int]struct{}
	cleared_PrefixToPatient bool
	done                    bool
	oldValue                func(context.Context) (*Prefix, error)
	predicates              []predicate.Prefix
}

var _ ent.Mutation = (*PrefixMutation)(nil)

// prefixOption allows management of the mutation configuration using functional options.
type prefixOption func(*PrefixMutation)

// newPrefixMutation creates new mutation for the Prefix entity.
func newPrefixMutation(c config, op Op, opts ...prefixOption) *PrefixMutation {
	m := &PrefixMutation{
		config:        c,
		op:            op,
		typ:           TypePrefix,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrefixID sets the ID field of the mutation.
func withPrefixID(id int) prefixOption {
	return func(m *PrefixMutation) {
		var (
			err   error
			once  sync.Once
			value *Prefix
		)
		m.oldValue = func(ctx context.Context) (*Prefix, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prefix.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrefix sets the old Prefix of the mutation.
func withPrefix(node *Prefix) prefixOption {
	return func(m *PrefixMutation) {
		m.oldValue = func(context.Context) (*Prefix, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrefixMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrefixMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PrefixMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrefix sets the "prefix" field.
func (m *PrefixMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *PrefixMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the Prefix entity.
// If the Prefix object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrefixMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *PrefixMutation) ResetPrefix() {
	m.prefix = nil
}

// AddPrefixToPatientIDs adds the "PrefixToPatient" edge to the Patient entity by ids.
func (m *PrefixMutation) AddPrefixToPatientIDs(ids ...int) {
	if m._PrefixToPatient == nil {
		m._PrefixToPatient = make(map[int]struct{})
	}
	for i := range ids {
		m._PrefixToPatient[ids[i]] = struct{}{}
	}
}

// ClearPrefixToPatient clears the "PrefixToPatient" edge to the Patient entity.
func (m *PrefixMutation) ClearPrefixToPatient() {
	m.cleared_PrefixToPatient = true
}

// PrefixToPatientCleared returns if the "PrefixToPatient" edge to the Patient entity was cleared.
func (m *PrefixMutation) PrefixToPatientCleared() bool {
	return m.cleared_PrefixToPatient
}

// RemovePrefixToPatientIDs removes the "PrefixToPatient" edge to the Patient entity by IDs.
func (m *PrefixMutation) RemovePrefixToPatientIDs(ids ...int) {
	if m.removed_PrefixToPatient == nil {
		m.removed_PrefixToPatient = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_PrefixToPatient[ids[i]] = struct{}{}
	}
}

// RemovedPrefixToPatient returns the removed IDs of the "PrefixToPatient" edge to the Patient entity.
func (m *PrefixMutation) RemovedPrefixToPatientIDs() (ids []int) {
	for id := range m.removed_PrefixToPatient {
		ids = append(ids, id)
	}
	return
}

// PrefixToPatientIDs returns the "PrefixToPatient" edge IDs in the mutation.
func (m *PrefixMutation) PrefixToPatientIDs() (ids []int) {
	for id := range m._PrefixToPatient {
		ids = append(ids, id)
	}
	return
}

// ResetPrefixToPatient resets all changes to the "PrefixToPatient" edge.
func (m *PrefixMutation) ResetPrefixToPatient() {
	m._PrefixToPatient = nil
	m.cleared_PrefixToPatient = false
	m.removed_PrefixToPatient = nil
}

// Op returns the operation name.
func (m *PrefixMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prefix).
func (m *PrefixMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrefixMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.prefix != nil {
		fields = append(fields, prefix.FieldPrefix)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrefixMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prefix.FieldPrefix:
		return m.Prefix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrefixMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prefix.FieldPrefix:
		return m.OldPrefix(ctx)
	}
	return nil, fmt.Errorf("unknown Prefix field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrefixMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prefix.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrefixMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrefixMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrefixMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrefixMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrefixMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrefixMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prefix nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrefixMutation) ResetField(name string) error {
	switch name {
	case prefix.FieldPrefix:
		m.ResetPrefix()
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrefixMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._PrefixToPatient != nil {
		edges = append(edges, prefix.EdgePrefixToPatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrefixMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePrefixToPatient:
		ids := make([]ent.Value, 0, len(m._PrefixToPatient))
		for id := range m._PrefixToPatient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrefixMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_PrefixToPatient != nil {
		edges = append(edges, prefix.EdgePrefixToPatient)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrefixMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePrefixToPatient:
		ids := make([]ent.Value, 0, len(m.removed_PrefixToPatient))
		for id := range m.removed_PrefixToPatient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrefixMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_PrefixToPatient {
		edges = append(edges, prefix.EdgePrefixToPatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrefixMutation) EdgeCleared(name string) bool {
	switch name {
	case prefix.EdgePrefixToPatient:
		return m.cleared_PrefixToPatient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrefixMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrefixMutation) ResetEdge(name string) error {
	switch name {
	case prefix.EdgePrefixToPatient:
		m.ResetPrefixToPatient()
		return nil
	}
	return fmt.Errorf("unknown Prefix edge %s", name)
}

// ProcedureTypeMutation represents an operation that mutates the ProcedureType nodes in the graph.
type ProcedureTypeMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	_ProcedureName                      *string
	clearedFields                       map[string]struct{}
	_ProcedureToMedicalProcedure        map[int]struct{}
	removed_ProcedureToMedicalProcedure map[int]struct{}
	cleared_ProcedureToMedicalProcedure bool
	done                                bool
	oldValue                            func(context.Context) (*ProcedureType, error)
	predicates                          []predicate.ProcedureType
}

var _ ent.Mutation = (*ProcedureTypeMutation)(nil)

// proceduretypeOption allows management of the mutation configuration using functional options.
type proceduretypeOption func(*ProcedureTypeMutation)

// newProcedureTypeMutation creates new mutation for the ProcedureType entity.
func newProcedureTypeMutation(c config, op Op, opts ...proceduretypeOption) *ProcedureTypeMutation {
	m := &ProcedureTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProcedureType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcedureTypeID sets the ID field of the mutation.
func withProcedureTypeID(id int) proceduretypeOption {
	return func(m *ProcedureTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcedureType
		)
		m.oldValue = func(ctx context.Context) (*ProcedureType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcedureType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcedureType sets the old ProcedureType of the mutation.
func withProcedureType(node *ProcedureType) proceduretypeOption {
	return func(m *ProcedureTypeMutation) {
		m.oldValue = func(context.Context) (*ProcedureType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcedureTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcedureTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProcedureTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProcedureName sets the "ProcedureName" field.
func (m *ProcedureTypeMutation) SetProcedureName(s string) {
	m._ProcedureName = &s
}

// ProcedureName returns the value of the "ProcedureName" field in the mutation.
func (m *ProcedureTypeMutation) ProcedureName() (r string, exists bool) {
	v := m._ProcedureName
	if v == nil {
		return
	}
	return *v, true
}

// OldProcedureName returns the old "ProcedureName" field's value of the ProcedureType entity.
// If the ProcedureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureTypeMutation) OldProcedureName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProcedureName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProcedureName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcedureName: %w", err)
	}
	return oldValue.ProcedureName, nil
}

// ResetProcedureName resets all changes to the "ProcedureName" field.
func (m *ProcedureTypeMutation) ResetProcedureName() {
	m._ProcedureName = nil
}

// AddProcedureToMedicalProcedureIDs adds the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity by ids.
func (m *ProcedureTypeMutation) AddProcedureToMedicalProcedureIDs(ids ...int) {
	if m._ProcedureToMedicalProcedure == nil {
		m._ProcedureToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m._ProcedureToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// ClearProcedureToMedicalProcedure clears the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *ProcedureTypeMutation) ClearProcedureToMedicalProcedure() {
	m.cleared_ProcedureToMedicalProcedure = true
}

// ProcedureToMedicalProcedureCleared returns if the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity was cleared.
func (m *ProcedureTypeMutation) ProcedureToMedicalProcedureCleared() bool {
	return m.cleared_ProcedureToMedicalProcedure
}

// RemoveProcedureToMedicalProcedureIDs removes the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity by IDs.
func (m *ProcedureTypeMutation) RemoveProcedureToMedicalProcedureIDs(ids ...int) {
	if m.removed_ProcedureToMedicalProcedure == nil {
		m.removed_ProcedureToMedicalProcedure = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProcedureToMedicalProcedure[ids[i]] = struct{}{}
	}
}

// RemovedProcedureToMedicalProcedure returns the removed IDs of the "ProcedureToMedicalProcedure" edge to the MedicalProcedure entity.
func (m *ProcedureTypeMutation) RemovedProcedureToMedicalProcedureIDs() (ids []int) {
	for id := range m.removed_ProcedureToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ProcedureToMedicalProcedureIDs returns the "ProcedureToMedicalProcedure" edge IDs in the mutation.
func (m *ProcedureTypeMutation) ProcedureToMedicalProcedureIDs() (ids []int) {
	for id := range m._ProcedureToMedicalProcedure {
		ids = append(ids, id)
	}
	return
}

// ResetProcedureToMedicalProcedure resets all changes to the "ProcedureToMedicalProcedure" edge.
func (m *ProcedureTypeMutation) ResetProcedureToMedicalProcedure() {
	m._ProcedureToMedicalProcedure = nil
	m.cleared_ProcedureToMedicalProcedure = false
	m.removed_ProcedureToMedicalProcedure = nil
}

// Op returns the operation name.
func (m *ProcedureTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProcedureType).
func (m *ProcedureTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcedureTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ProcedureName != nil {
		fields = append(fields, proceduretype.FieldProcedureName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcedureTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proceduretype.FieldProcedureName:
		return m.ProcedureName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcedureTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proceduretype.FieldProcedureName:
		return m.OldProcedureName(ctx)
	}
	return nil, fmt.Errorf("unknown ProcedureType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proceduretype.FieldProcedureName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcedureName(v)
		return nil
	}
	return fmt.Errorf("unknown ProcedureType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcedureTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcedureTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProcedureType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcedureTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcedureTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcedureTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProcedureType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcedureTypeMutation) ResetField(name string) error {
	switch name {
	case proceduretype.FieldProcedureName:
		m.ResetProcedureName()
		return nil
	}
	return fmt.Errorf("unknown ProcedureType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcedureTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ProcedureToMedicalProcedure != nil {
		edges = append(edges, proceduretype.EdgeProcedureToMedicalProcedure)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcedureTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m._ProcedureToMedicalProcedure))
		for id := range m._ProcedureToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcedureTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_ProcedureToMedicalProcedure != nil {
		edges = append(edges, proceduretype.EdgeProcedureToMedicalProcedure)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcedureTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		ids := make([]ent.Value, 0, len(m.removed_ProcedureToMedicalProcedure))
		for id := range m.removed_ProcedureToMedicalProcedure {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcedureTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ProcedureToMedicalProcedure {
		edges = append(edges, proceduretype.EdgeProcedureToMedicalProcedure)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcedureTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		return m.cleared_ProcedureToMedicalProcedure
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcedureTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProcedureType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcedureTypeMutation) ResetEdge(name string) error {
	switch name {
	case proceduretype.EdgeProcedureToMedicalProcedure:
		m.ResetProcedureToMedicalProcedure()
		return nil
	}
	return fmt.Errorf("unknown ProcedureType edge %s", name)
}

// RightToTreatmentMutation represents an operation that mutates the RightToTreatment nodes in the graph.
type RightToTreatmentMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_Addedtime                   *time.Time
	clearedFields                map[string]struct{}
	_Hospital                    *int
	cleared_Hospital             bool
	_RightToTreatmentType        *int
	cleared_RightToTreatmentType bool
	_Patient                     *int
	cleared_Patient              bool
	done                         bool
	oldValue                     func(context.Context) (*RightToTreatment, error)
	predicates                   []predicate.RightToTreatment
}

var _ ent.Mutation = (*RightToTreatmentMutation)(nil)

// righttotreatmentOption allows management of the mutation configuration using functional options.
type righttotreatmentOption func(*RightToTreatmentMutation)

// newRightToTreatmentMutation creates new mutation for the RightToTreatment entity.
func newRightToTreatmentMutation(c config, op Op, opts ...righttotreatmentOption) *RightToTreatmentMutation {
	m := &RightToTreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeRightToTreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRightToTreatmentID sets the ID field of the mutation.
func withRightToTreatmentID(id int) righttotreatmentOption {
	return func(m *RightToTreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *RightToTreatment
		)
		m.oldValue = func(ctx context.Context) (*RightToTreatment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RightToTreatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRightToTreatment sets the old RightToTreatment of the mutation.
func withRightToTreatment(node *RightToTreatment) righttotreatmentOption {
	return func(m *RightToTreatmentMutation) {
		m.oldValue = func(context.Context) (*RightToTreatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RightToTreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RightToTreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RightToTreatmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the "Addedtime" field.
func (m *RightToTreatmentMutation) SetAddedtime(t time.Time) {
	m._Addedtime = &t
}

// Addedtime returns the value of the "Addedtime" field in the mutation.
func (m *RightToTreatmentMutation) Addedtime() (r time.Time, exists bool) {
	v := m._Addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old "Addedtime" field's value of the RightToTreatment entity.
// If the RightToTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RightToTreatmentMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime resets all changes to the "Addedtime" field.
func (m *RightToTreatmentMutation) ResetAddedtime() {
	m._Addedtime = nil
}

// SetHospitalID sets the "Hospital" edge to the Hospital entity by id.
func (m *RightToTreatmentMutation) SetHospitalID(id int) {
	m._Hospital = &id
}

// ClearHospital clears the "Hospital" edge to the Hospital entity.
func (m *RightToTreatmentMutation) ClearHospital() {
	m.cleared_Hospital = true
}

// HospitalCleared returns if the "Hospital" edge to the Hospital entity was cleared.
func (m *RightToTreatmentMutation) HospitalCleared() bool {
	return m.cleared_Hospital
}

// HospitalID returns the "Hospital" edge ID in the mutation.
func (m *RightToTreatmentMutation) HospitalID() (id int, exists bool) {
	if m._Hospital != nil {
		return *m._Hospital, true
	}
	return
}

// HospitalIDs returns the "Hospital" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HospitalID instead. It exists only for internal usage by the builders.
func (m *RightToTreatmentMutation) HospitalIDs() (ids []int) {
	if id := m._Hospital; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHospital resets all changes to the "Hospital" edge.
func (m *RightToTreatmentMutation) ResetHospital() {
	m._Hospital = nil
	m.cleared_Hospital = false
}

// SetRightToTreatmentTypeID sets the "RightToTreatmentType" edge to the RightToTreatmentType entity by id.
func (m *RightToTreatmentMutation) SetRightToTreatmentTypeID(id int) {
	m._RightToTreatmentType = &id
}

// ClearRightToTreatmentType clears the "RightToTreatmentType" edge to the RightToTreatmentType entity.
func (m *RightToTreatmentMutation) ClearRightToTreatmentType() {
	m.cleared_RightToTreatmentType = true
}

// RightToTreatmentTypeCleared returns if the "RightToTreatmentType" edge to the RightToTreatmentType entity was cleared.
func (m *RightToTreatmentMutation) RightToTreatmentTypeCleared() bool {
	return m.cleared_RightToTreatmentType
}

// RightToTreatmentTypeID returns the "RightToTreatmentType" edge ID in the mutation.
func (m *RightToTreatmentMutation) RightToTreatmentTypeID() (id int, exists bool) {
	if m._RightToTreatmentType != nil {
		return *m._RightToTreatmentType, true
	}
	return
}

// RightToTreatmentTypeIDs returns the "RightToTreatmentType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RightToTreatmentTypeID instead. It exists only for internal usage by the builders.
func (m *RightToTreatmentMutation) RightToTreatmentTypeIDs() (ids []int) {
	if id := m._RightToTreatmentType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRightToTreatmentType resets all changes to the "RightToTreatmentType" edge.
func (m *RightToTreatmentMutation) ResetRightToTreatmentType() {
	m._RightToTreatmentType = nil
	m.cleared_RightToTreatmentType = false
}

// SetPatientID sets the "Patient" edge to the Patient entity by id.
func (m *RightToTreatmentMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the "Patient" edge to the Patient entity.
func (m *RightToTreatmentMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the "Patient" edge to the Patient entity was cleared.
func (m *RightToTreatmentMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the "Patient" edge ID in the mutation.
func (m *RightToTreatmentMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the "Patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *RightToTreatmentMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "Patient" edge.
func (m *RightToTreatmentMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// Op returns the operation name.
func (m *RightToTreatmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RightToTreatment).
func (m *RightToTreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RightToTreatmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Addedtime != nil {
		fields = append(fields, righttotreatment.FieldAddedtime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RightToTreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case righttotreatment.FieldAddedtime:
		return m.Addedtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RightToTreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case righttotreatment.FieldAddedtime:
		return m.OldAddedtime(ctx)
	}
	return nil, fmt.Errorf("unknown RightToTreatment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case righttotreatment.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RightToTreatmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RightToTreatmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RightToTreatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RightToTreatmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RightToTreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RightToTreatmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RightToTreatment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RightToTreatmentMutation) ResetField(name string) error {
	switch name {
	case righttotreatment.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RightToTreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Hospital != nil {
		edges = append(edges, righttotreatment.EdgeHospital)
	}
	if m._RightToTreatmentType != nil {
		edges = append(edges, righttotreatment.EdgeRightToTreatmentType)
	}
	if m._Patient != nil {
		edges = append(edges, righttotreatment.EdgePatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RightToTreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case righttotreatment.EdgeHospital:
		if id := m._Hospital; id != nil {
			return []ent.Value{*id}
		}
	case righttotreatment.EdgeRightToTreatmentType:
		if id := m._RightToTreatmentType; id != nil {
			return []ent.Value{*id}
		}
	case righttotreatment.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RightToTreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RightToTreatmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RightToTreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Hospital {
		edges = append(edges, righttotreatment.EdgeHospital)
	}
	if m.cleared_RightToTreatmentType {
		edges = append(edges, righttotreatment.EdgeRightToTreatmentType)
	}
	if m.cleared_Patient {
		edges = append(edges, righttotreatment.EdgePatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RightToTreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	case righttotreatment.EdgeHospital:
		return m.cleared_Hospital
	case righttotreatment.EdgeRightToTreatmentType:
		return m.cleared_RightToTreatmentType
	case righttotreatment.EdgePatient:
		return m.cleared_Patient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RightToTreatmentMutation) ClearEdge(name string) error {
	switch name {
	case righttotreatment.EdgeHospital:
		m.ClearHospital()
		return nil
	case righttotreatment.EdgeRightToTreatmentType:
		m.ClearRightToTreatmentType()
		return nil
	case righttotreatment.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RightToTreatmentMutation) ResetEdge(name string) error {
	switch name {
	case righttotreatment.EdgeHospital:
		m.ResetHospital()
		return nil
	case righttotreatment.EdgeRightToTreatmentType:
		m.ResetRightToTreatmentType()
		return nil
	case righttotreatment.EdgePatient:
		m.ResetPatient()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatment edge %s", name)
}

// RightToTreatmentTypeMutation represents an operation that mutates the RightToTreatmentType nodes in the graph.
type RightToTreatmentTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_TypeName     *string
	clearedFields map[string]struct{}
	_type         map[int]struct{}
	removed_type  map[int]struct{}
	cleared_type  bool
	done          bool
	oldValue      func(context.Context) (*RightToTreatmentType, error)
	predicates    []predicate.RightToTreatmentType
}

var _ ent.Mutation = (*RightToTreatmentTypeMutation)(nil)

// righttotreatmenttypeOption allows management of the mutation configuration using functional options.
type righttotreatmenttypeOption func(*RightToTreatmentTypeMutation)

// newRightToTreatmentTypeMutation creates new mutation for the RightToTreatmentType entity.
func newRightToTreatmentTypeMutation(c config, op Op, opts ...righttotreatmenttypeOption) *RightToTreatmentTypeMutation {
	m := &RightToTreatmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeRightToTreatmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRightToTreatmentTypeID sets the ID field of the mutation.
func withRightToTreatmentTypeID(id int) righttotreatmenttypeOption {
	return func(m *RightToTreatmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *RightToTreatmentType
		)
		m.oldValue = func(ctx context.Context) (*RightToTreatmentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RightToTreatmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRightToTreatmentType sets the old RightToTreatmentType of the mutation.
func withRightToTreatmentType(node *RightToTreatmentType) righttotreatmenttypeOption {
	return func(m *RightToTreatmentTypeMutation) {
		m.oldValue = func(context.Context) (*RightToTreatmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RightToTreatmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RightToTreatmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RightToTreatmentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTypeName sets the "TypeName" field.
func (m *RightToTreatmentTypeMutation) SetTypeName(s string) {
	m._TypeName = &s
}

// TypeName returns the value of the "TypeName" field in the mutation.
func (m *RightToTreatmentTypeMutation) TypeName() (r string, exists bool) {
	v := m._TypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "TypeName" field's value of the RightToTreatmentType entity.
// If the RightToTreatmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RightToTreatmentTypeMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "TypeName" field.
func (m *RightToTreatmentTypeMutation) ResetTypeName() {
	m._TypeName = nil
}

// AddTypeIDs adds the "type" edge to the RightToTreatment entity by ids.
func (m *RightToTreatmentTypeMutation) AddTypeIDs(ids ...int) {
	if m._type == nil {
		m._type = make(map[int]struct{})
	}
	for i := range ids {
		m._type[ids[i]] = struct{}{}
	}
}

// ClearType clears the "type" edge to the RightToTreatment entity.
func (m *RightToTreatmentTypeMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the "type" edge to the RightToTreatment entity was cleared.
func (m *RightToTreatmentTypeMutation) TypeCleared() bool {
	return m.cleared_type
}

// RemoveTypeIDs removes the "type" edge to the RightToTreatment entity by IDs.
func (m *RightToTreatmentTypeMutation) RemoveTypeIDs(ids ...int) {
	if m.removed_type == nil {
		m.removed_type = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_type[ids[i]] = struct{}{}
	}
}

// RemovedType returns the removed IDs of the "type" edge to the RightToTreatment entity.
func (m *RightToTreatmentTypeMutation) RemovedTypeIDs() (ids []int) {
	for id := range m.removed_type {
		ids = append(ids, id)
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
func (m *RightToTreatmentTypeMutation) TypeIDs() (ids []int) {
	for id := range m._type {
		ids = append(ids, id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *RightToTreatmentTypeMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
	m.removed_type = nil
}

// Op returns the operation name.
func (m *RightToTreatmentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RightToTreatmentType).
func (m *RightToTreatmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RightToTreatmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TypeName != nil {
		fields = append(fields, righttotreatmenttype.FieldTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RightToTreatmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		return m.TypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RightToTreatmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		return m.OldTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown RightToTreatmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown RightToTreatmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RightToTreatmentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RightToTreatmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RightToTreatmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RightToTreatmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RightToTreatmentTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RightToTreatmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RightToTreatmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ResetField(name string) error {
	switch name {
	case righttotreatmenttype.FieldTypeName:
		m.ResetTypeName()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RightToTreatmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._type != nil {
		edges = append(edges, righttotreatmenttype.EdgeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RightToTreatmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case righttotreatmenttype.EdgeType:
		ids := make([]ent.Value, 0, len(m._type))
		for id := range m._type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RightToTreatmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_type != nil {
		edges = append(edges, righttotreatmenttype.EdgeType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RightToTreatmentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case righttotreatmenttype.EdgeType:
		ids := make([]ent.Value, 0, len(m.removed_type))
		for id := range m.removed_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RightToTreatmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_type {
		edges = append(edges, righttotreatmenttype.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RightToTreatmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case righttotreatmenttype.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RightToTreatmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RightToTreatmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case righttotreatmenttype.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown RightToTreatmentType edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	roomName                         *string
	clearedFields                    map[string]struct{}
	_RoomToAppointmentResults        map[int]struct{}
	removed_RoomToAppointmentResults map[int]struct{}
	cleared_RoomToAppointmentResults bool
	done                             bool
	oldValue                         func(context.Context) (*Room, error)
	predicates                       []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomName sets the "roomName" field.
func (m *RoomMutation) SetRoomName(s string) {
	m.roomName = &s
}

// RoomName returns the value of the "roomName" field in the mutation.
func (m *RoomMutation) RoomName() (r string, exists bool) {
	v := m.roomName
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomName returns the old "roomName" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldRoomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomName: %w", err)
	}
	return oldValue.RoomName, nil
}

// ResetRoomName resets all changes to the "roomName" field.
func (m *RoomMutation) ResetRoomName() {
	m.roomName = nil
}

// AddRoomToAppointmentResultIDs adds the "RoomToAppointmentResults" edge to the AppointmentResults entity by ids.
func (m *RoomMutation) AddRoomToAppointmentResultIDs(ids ...int) {
	if m._RoomToAppointmentResults == nil {
		m._RoomToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m._RoomToAppointmentResults[ids[i]] = struct{}{}
	}
}

// ClearRoomToAppointmentResults clears the "RoomToAppointmentResults" edge to the AppointmentResults entity.
func (m *RoomMutation) ClearRoomToAppointmentResults() {
	m.cleared_RoomToAppointmentResults = true
}

// RoomToAppointmentResultsCleared returns if the "RoomToAppointmentResults" edge to the AppointmentResults entity was cleared.
func (m *RoomMutation) RoomToAppointmentResultsCleared() bool {
	return m.cleared_RoomToAppointmentResults
}

// RemoveRoomToAppointmentResultIDs removes the "RoomToAppointmentResults" edge to the AppointmentResults entity by IDs.
func (m *RoomMutation) RemoveRoomToAppointmentResultIDs(ids ...int) {
	if m.removed_RoomToAppointmentResults == nil {
		m.removed_RoomToAppointmentResults = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_RoomToAppointmentResults[ids[i]] = struct{}{}
	}
}

// RemovedRoomToAppointmentResults returns the removed IDs of the "RoomToAppointmentResults" edge to the AppointmentResults entity.
func (m *RoomMutation) RemovedRoomToAppointmentResultsIDs() (ids []int) {
	for id := range m.removed_RoomToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// RoomToAppointmentResultsIDs returns the "RoomToAppointmentResults" edge IDs in the mutation.
func (m *RoomMutation) RoomToAppointmentResultsIDs() (ids []int) {
	for id := range m._RoomToAppointmentResults {
		ids = append(ids, id)
	}
	return
}

// ResetRoomToAppointmentResults resets all changes to the "RoomToAppointmentResults" edge.
func (m *RoomMutation) ResetRoomToAppointmentResults() {
	m._RoomToAppointmentResults = nil
	m.cleared_RoomToAppointmentResults = false
	m.removed_RoomToAppointmentResults = nil
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.roomName != nil {
		fields = append(fields, room.FieldRoomName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRoomName:
		return m.RoomName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldRoomName:
		return m.OldRoomName(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldRoomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomName(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldRoomName:
		m.ResetRoomName()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._RoomToAppointmentResults != nil {
		edges = append(edges, room.EdgeRoomToAppointmentResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		ids := make([]ent.Value, 0, len(m._RoomToAppointmentResults))
		for id := range m._RoomToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_RoomToAppointmentResults != nil {
		edges = append(edges, room.EdgeRoomToAppointmentResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		ids := make([]ent.Value, 0, len(m.removed_RoomToAppointmentResults))
		for id := range m.removed_RoomToAppointmentResults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_RoomToAppointmentResults {
		edges = append(edges, room.EdgeRoomToAppointmentResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		return m.cleared_RoomToAppointmentResults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeRoomToAppointmentResults:
		m.ResetRoomToAppointmentResults()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// TreatmentTypeMutation represents an operation that mutates the TreatmentType nodes in the graph.
type TreatmentTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	_Type                            *string
	clearedFields                    map[string]struct{}
	_TreatmentTypeToDiagnosis        map[int]struct{}
	removed_TreatmentTypeToDiagnosis map[int]struct{}
	cleared_TreatmentTypeToDiagnosis bool
	done                             bool
	oldValue                         func(context.Context) (*TreatmentType, error)
	predicates                       []predicate.TreatmentType
}

var _ ent.Mutation = (*TreatmentTypeMutation)(nil)

// treatmenttypeOption allows management of the mutation configuration using functional options.
type treatmenttypeOption func(*TreatmentTypeMutation)

// newTreatmentTypeMutation creates new mutation for the TreatmentType entity.
func newTreatmentTypeMutation(c config, op Op, opts ...treatmenttypeOption) *TreatmentTypeMutation {
	m := &TreatmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentTypeID sets the ID field of the mutation.
func withTreatmentTypeID(id int) treatmenttypeOption {
	return func(m *TreatmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TreatmentType
		)
		m.oldValue = func(ctx context.Context) (*TreatmentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreatmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatmentType sets the old TreatmentType of the mutation.
func withTreatmentType(node *TreatmentType) treatmenttypeOption {
	return func(m *TreatmentTypeMutation) {
		m.oldValue = func(context.Context) (*TreatmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TreatmentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "Type" field.
func (m *TreatmentTypeMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *TreatmentTypeMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the TreatmentType entity.
// If the TreatmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreatmentTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *TreatmentTypeMutation) ResetType() {
	m._Type = nil
}

// AddTreatmentTypeToDiagnosiIDs adds the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity by ids.
func (m *TreatmentTypeMutation) AddTreatmentTypeToDiagnosiIDs(ids ...int) {
	if m._TreatmentTypeToDiagnosis == nil {
		m._TreatmentTypeToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m._TreatmentTypeToDiagnosis[ids[i]] = struct{}{}
	}
}

// ClearTreatmentTypeToDiagnosis clears the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity.
func (m *TreatmentTypeMutation) ClearTreatmentTypeToDiagnosis() {
	m.cleared_TreatmentTypeToDiagnosis = true
}

// TreatmentTypeToDiagnosisCleared returns if the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity was cleared.
func (m *TreatmentTypeMutation) TreatmentTypeToDiagnosisCleared() bool {
	return m.cleared_TreatmentTypeToDiagnosis
}

// RemoveTreatmentTypeToDiagnosiIDs removes the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity by IDs.
func (m *TreatmentTypeMutation) RemoveTreatmentTypeToDiagnosiIDs(ids ...int) {
	if m.removed_TreatmentTypeToDiagnosis == nil {
		m.removed_TreatmentTypeToDiagnosis = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TreatmentTypeToDiagnosis[ids[i]] = struct{}{}
	}
}

// RemovedTreatmentTypeToDiagnosis returns the removed IDs of the "TreatmentTypeToDiagnosis" edge to the Diagnosis entity.
func (m *TreatmentTypeMutation) RemovedTreatmentTypeToDiagnosisIDs() (ids []int) {
	for id := range m.removed_TreatmentTypeToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// TreatmentTypeToDiagnosisIDs returns the "TreatmentTypeToDiagnosis" edge IDs in the mutation.
func (m *TreatmentTypeMutation) TreatmentTypeToDiagnosisIDs() (ids []int) {
	for id := range m._TreatmentTypeToDiagnosis {
		ids = append(ids, id)
	}
	return
}

// ResetTreatmentTypeToDiagnosis resets all changes to the "TreatmentTypeToDiagnosis" edge.
func (m *TreatmentTypeMutation) ResetTreatmentTypeToDiagnosis() {
	m._TreatmentTypeToDiagnosis = nil
	m.cleared_TreatmentTypeToDiagnosis = false
	m.removed_TreatmentTypeToDiagnosis = nil
}

// Op returns the operation name.
func (m *TreatmentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TreatmentType).
func (m *TreatmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreatmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Type != nil {
		fields = append(fields, treatmenttype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreatmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatmenttype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreatmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatmenttype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown TreatmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreatmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatmenttype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown TreatmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreatmentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreatmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreatmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreatmentTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreatmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TreatmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreatmentTypeMutation) ResetField(name string) error {
	switch name {
	case treatmenttype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown TreatmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreatmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._TreatmentTypeToDiagnosis != nil {
		edges = append(edges, treatmenttype.EdgeTreatmentTypeToDiagnosis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreatmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		ids := make([]ent.Value, 0, len(m._TreatmentTypeToDiagnosis))
		for id := range m._TreatmentTypeToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreatmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_TreatmentTypeToDiagnosis != nil {
		edges = append(edges, treatmenttype.EdgeTreatmentTypeToDiagnosis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreatmentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		ids := make([]ent.Value, 0, len(m.removed_TreatmentTypeToDiagnosis))
		for id := range m.removed_TreatmentTypeToDiagnosis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreatmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_TreatmentTypeToDiagnosis {
		edges = append(edges, treatmenttype.EdgeTreatmentTypeToDiagnosis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreatmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		return m.cleared_TreatmentTypeToDiagnosis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreatmentTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreatmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case treatmenttype.EdgeTreatmentTypeToDiagnosis:
		m.ResetTreatmentTypeToDiagnosis()
		return nil
	}
	return fmt.Errorf("unknown TreatmentType edge %s", name)
}

// TriageResultMutation represents an operation that mutates the TriageResult nodes in the graph.
type TriageResultMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	symptom                           *string
	triageDate                        *time.Time
	clearedFields                     map[string]struct{}
	triageResultToUrgencyLevel        *int
	clearedtriageResultToUrgencyLevel bool
	triageResultToDepartment          *int
	clearedtriageResultToDepartment   bool
	triageResultToNurse               *int
	clearedtriageResultToNurse        bool
	triageResultToPatient             *int
	clearedtriageResultToPatient      bool
	done                              bool
	oldValue                          func(context.Context) (*TriageResult, error)
	predicates                        []predicate.TriageResult
}

var _ ent.Mutation = (*TriageResultMutation)(nil)

// triageresultOption allows management of the mutation configuration using functional options.
type triageresultOption func(*TriageResultMutation)

// newTriageResultMutation creates new mutation for the TriageResult entity.
func newTriageResultMutation(c config, op Op, opts ...triageresultOption) *TriageResultMutation {
	m := &TriageResultMutation{
		config:        c,
		op:            op,
		typ:           TypeTriageResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTriageResultID sets the ID field of the mutation.
func withTriageResultID(id int) triageresultOption {
	return func(m *TriageResultMutation) {
		var (
			err   error
			once  sync.Once
			value *TriageResult
		)
		m.oldValue = func(ctx context.Context) (*TriageResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TriageResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTriageResult sets the old TriageResult of the mutation.
func withTriageResult(node *TriageResult) triageresultOption {
	return func(m *TriageResultMutation) {
		m.oldValue = func(context.Context) (*TriageResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TriageResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TriageResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TriageResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptom sets the "symptom" field.
func (m *TriageResultMutation) SetSymptom(s string) {
	m.symptom = &s
}

// Symptom returns the value of the "symptom" field in the mutation.
func (m *TriageResultMutation) Symptom() (r string, exists bool) {
	v := m.symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old "symptom" field's value of the TriageResult entity.
// If the TriageResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TriageResultMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom resets all changes to the "symptom" field.
func (m *TriageResultMutation) ResetSymptom() {
	m.symptom = nil
}

// SetTriageDate sets the "triageDate" field.
func (m *TriageResultMutation) SetTriageDate(t time.Time) {
	m.triageDate = &t
}

// TriageDate returns the value of the "triageDate" field in the mutation.
func (m *TriageResultMutation) TriageDate() (r time.Time, exists bool) {
	v := m.triageDate
	if v == nil {
		return
	}
	return *v, true
}

// OldTriageDate returns the old "triageDate" field's value of the TriageResult entity.
// If the TriageResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TriageResultMutation) OldTriageDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTriageDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTriageDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriageDate: %w", err)
	}
	return oldValue.TriageDate, nil
}

// ResetTriageDate resets all changes to the "triageDate" field.
func (m *TriageResultMutation) ResetTriageDate() {
	m.triageDate = nil
}

// SetTriageResultToUrgencyLevelID sets the "triageResultToUrgencyLevel" edge to the UrgencyLevel entity by id.
func (m *TriageResultMutation) SetTriageResultToUrgencyLevelID(id int) {
	m.triageResultToUrgencyLevel = &id
}

// ClearTriageResultToUrgencyLevel clears the "triageResultToUrgencyLevel" edge to the UrgencyLevel entity.
func (m *TriageResultMutation) ClearTriageResultToUrgencyLevel() {
	m.clearedtriageResultToUrgencyLevel = true
}

// TriageResultToUrgencyLevelCleared returns if the "triageResultToUrgencyLevel" edge to the UrgencyLevel entity was cleared.
func (m *TriageResultMutation) TriageResultToUrgencyLevelCleared() bool {
	return m.clearedtriageResultToUrgencyLevel
}

// TriageResultToUrgencyLevelID returns the "triageResultToUrgencyLevel" edge ID in the mutation.
func (m *TriageResultMutation) TriageResultToUrgencyLevelID() (id int, exists bool) {
	if m.triageResultToUrgencyLevel != nil {
		return *m.triageResultToUrgencyLevel, true
	}
	return
}

// TriageResultToUrgencyLevelIDs returns the "triageResultToUrgencyLevel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TriageResultToUrgencyLevelID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) TriageResultToUrgencyLevelIDs() (ids []int) {
	if id := m.triageResultToUrgencyLevel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTriageResultToUrgencyLevel resets all changes to the "triageResultToUrgencyLevel" edge.
func (m *TriageResultMutation) ResetTriageResultToUrgencyLevel() {
	m.triageResultToUrgencyLevel = nil
	m.clearedtriageResultToUrgencyLevel = false
}

// SetTriageResultToDepartmentID sets the "triageResultToDepartment" edge to the Department entity by id.
func (m *TriageResultMutation) SetTriageResultToDepartmentID(id int) {
	m.triageResultToDepartment = &id
}

// ClearTriageResultToDepartment clears the "triageResultToDepartment" edge to the Department entity.
func (m *TriageResultMutation) ClearTriageResultToDepartment() {
	m.clearedtriageResultToDepartment = true
}

// TriageResultToDepartmentCleared returns if the "triageResultToDepartment" edge to the Department entity was cleared.
func (m *TriageResultMutation) TriageResultToDepartmentCleared() bool {
	return m.clearedtriageResultToDepartment
}

// TriageResultToDepartmentID returns the "triageResultToDepartment" edge ID in the mutation.
func (m *TriageResultMutation) TriageResultToDepartmentID() (id int, exists bool) {
	if m.triageResultToDepartment != nil {
		return *m.triageResultToDepartment, true
	}
	return
}

// TriageResultToDepartmentIDs returns the "triageResultToDepartment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TriageResultToDepartmentID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) TriageResultToDepartmentIDs() (ids []int) {
	if id := m.triageResultToDepartment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTriageResultToDepartment resets all changes to the "triageResultToDepartment" edge.
func (m *TriageResultMutation) ResetTriageResultToDepartment() {
	m.triageResultToDepartment = nil
	m.clearedtriageResultToDepartment = false
}

// SetTriageResultToNurseID sets the "triageResultToNurse" edge to the Nurse entity by id.
func (m *TriageResultMutation) SetTriageResultToNurseID(id int) {
	m.triageResultToNurse = &id
}

// ClearTriageResultToNurse clears the "triageResultToNurse" edge to the Nurse entity.
func (m *TriageResultMutation) ClearTriageResultToNurse() {
	m.clearedtriageResultToNurse = true
}

// TriageResultToNurseCleared returns if the "triageResultToNurse" edge to the Nurse entity was cleared.
func (m *TriageResultMutation) TriageResultToNurseCleared() bool {
	return m.clearedtriageResultToNurse
}

// TriageResultToNurseID returns the "triageResultToNurse" edge ID in the mutation.
func (m *TriageResultMutation) TriageResultToNurseID() (id int, exists bool) {
	if m.triageResultToNurse != nil {
		return *m.triageResultToNurse, true
	}
	return
}

// TriageResultToNurseIDs returns the "triageResultToNurse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TriageResultToNurseID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) TriageResultToNurseIDs() (ids []int) {
	if id := m.triageResultToNurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTriageResultToNurse resets all changes to the "triageResultToNurse" edge.
func (m *TriageResultMutation) ResetTriageResultToNurse() {
	m.triageResultToNurse = nil
	m.clearedtriageResultToNurse = false
}

// SetTriageResultToPatientID sets the "triageResultToPatient" edge to the Patient entity by id.
func (m *TriageResultMutation) SetTriageResultToPatientID(id int) {
	m.triageResultToPatient = &id
}

// ClearTriageResultToPatient clears the "triageResultToPatient" edge to the Patient entity.
func (m *TriageResultMutation) ClearTriageResultToPatient() {
	m.clearedtriageResultToPatient = true
}

// TriageResultToPatientCleared returns if the "triageResultToPatient" edge to the Patient entity was cleared.
func (m *TriageResultMutation) TriageResultToPatientCleared() bool {
	return m.clearedtriageResultToPatient
}

// TriageResultToPatientID returns the "triageResultToPatient" edge ID in the mutation.
func (m *TriageResultMutation) TriageResultToPatientID() (id int, exists bool) {
	if m.triageResultToPatient != nil {
		return *m.triageResultToPatient, true
	}
	return
}

// TriageResultToPatientIDs returns the "triageResultToPatient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TriageResultToPatientID instead. It exists only for internal usage by the builders.
func (m *TriageResultMutation) TriageResultToPatientIDs() (ids []int) {
	if id := m.triageResultToPatient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTriageResultToPatient resets all changes to the "triageResultToPatient" edge.
func (m *TriageResultMutation) ResetTriageResultToPatient() {
	m.triageResultToPatient = nil
	m.clearedtriageResultToPatient = false
}

// Op returns the operation name.
func (m *TriageResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TriageResult).
func (m *TriageResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TriageResultMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.symptom != nil {
		fields = append(fields, triageresult.FieldSymptom)
	}
	if m.triageDate != nil {
		fields = append(fields, triageresult.FieldTriageDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TriageResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case triageresult.FieldSymptom:
		return m.Symptom()
	case triageresult.FieldTriageDate:
		return m.TriageDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TriageResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case triageresult.FieldSymptom:
		return m.OldSymptom(ctx)
	case triageresult.FieldTriageDate:
		return m.OldTriageDate(ctx)
	}
	return nil, fmt.Errorf("unknown TriageResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TriageResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case triageresult.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case triageresult.FieldTriageDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriageDate(v)
		return nil
	}
	return fmt.Errorf("unknown TriageResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TriageResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TriageResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TriageResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TriageResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TriageResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TriageResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TriageResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TriageResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TriageResultMutation) ResetField(name string) error {
	switch name {
	case triageresult.FieldSymptom:
		m.ResetSymptom()
		return nil
	case triageresult.FieldTriageDate:
		m.ResetTriageDate()
		return nil
	}
	return fmt.Errorf("unknown TriageResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TriageResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.triageResultToUrgencyLevel != nil {
		edges = append(edges, triageresult.EdgeTriageResultToUrgencyLevel)
	}
	if m.triageResultToDepartment != nil {
		edges = append(edges, triageresult.EdgeTriageResultToDepartment)
	}
	if m.triageResultToNurse != nil {
		edges = append(edges, triageresult.EdgeTriageResultToNurse)
	}
	if m.triageResultToPatient != nil {
		edges = append(edges, triageresult.EdgeTriageResultToPatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TriageResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case triageresult.EdgeTriageResultToUrgencyLevel:
		if id := m.triageResultToUrgencyLevel; id != nil {
			return []ent.Value{*id}
		}
	case triageresult.EdgeTriageResultToDepartment:
		if id := m.triageResultToDepartment; id != nil {
			return []ent.Value{*id}
		}
	case triageresult.EdgeTriageResultToNurse:
		if id := m.triageResultToNurse; id != nil {
			return []ent.Value{*id}
		}
	case triageresult.EdgeTriageResultToPatient:
		if id := m.triageResultToPatient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TriageResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TriageResultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TriageResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtriageResultToUrgencyLevel {
		edges = append(edges, triageresult.EdgeTriageResultToUrgencyLevel)
	}
	if m.clearedtriageResultToDepartment {
		edges = append(edges, triageresult.EdgeTriageResultToDepartment)
	}
	if m.clearedtriageResultToNurse {
		edges = append(edges, triageresult.EdgeTriageResultToNurse)
	}
	if m.clearedtriageResultToPatient {
		edges = append(edges, triageresult.EdgeTriageResultToPatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TriageResultMutation) EdgeCleared(name string) bool {
	switch name {
	case triageresult.EdgeTriageResultToUrgencyLevel:
		return m.clearedtriageResultToUrgencyLevel
	case triageresult.EdgeTriageResultToDepartment:
		return m.clearedtriageResultToDepartment
	case triageresult.EdgeTriageResultToNurse:
		return m.clearedtriageResultToNurse
	case triageresult.EdgeTriageResultToPatient:
		return m.clearedtriageResultToPatient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TriageResultMutation) ClearEdge(name string) error {
	switch name {
	case triageresult.EdgeTriageResultToUrgencyLevel:
		m.ClearTriageResultToUrgencyLevel()
		return nil
	case triageresult.EdgeTriageResultToDepartment:
		m.ClearTriageResultToDepartment()
		return nil
	case triageresult.EdgeTriageResultToNurse:
		m.ClearTriageResultToNurse()
		return nil
	case triageresult.EdgeTriageResultToPatient:
		m.ClearTriageResultToPatient()
		return nil
	}
	return fmt.Errorf("unknown TriageResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TriageResultMutation) ResetEdge(name string) error {
	switch name {
	case triageresult.EdgeTriageResultToUrgencyLevel:
		m.ResetTriageResultToUrgencyLevel()
		return nil
	case triageresult.EdgeTriageResultToDepartment:
		m.ResetTriageResultToDepartment()
		return nil
	case triageresult.EdgeTriageResultToNurse:
		m.ResetTriageResultToNurse()
		return nil
	case triageresult.EdgeTriageResultToPatient:
		m.ResetTriageResultToPatient()
		return nil
	}
	return fmt.Errorf("unknown TriageResult edge %s", name)
}

// UrgencyLevelMutation represents an operation that mutates the UrgencyLevel nodes in the graph.
type UrgencyLevelMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	urgencyName                       *string
	clearedFields                     map[string]struct{}
	urgencyLevelToTriageResult        map[int]struct{}
	removedurgencyLevelToTriageResult map[int]struct{}
	clearedurgencyLevelToTriageResult bool
	done                              bool
	oldValue                          func(context.Context) (*UrgencyLevel, error)
	predicates                        []predicate.UrgencyLevel
}

var _ ent.Mutation = (*UrgencyLevelMutation)(nil)

// urgencylevelOption allows management of the mutation configuration using functional options.
type urgencylevelOption func(*UrgencyLevelMutation)

// newUrgencyLevelMutation creates new mutation for the UrgencyLevel entity.
func newUrgencyLevelMutation(c config, op Op, opts ...urgencylevelOption) *UrgencyLevelMutation {
	m := &UrgencyLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeUrgencyLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUrgencyLevelID sets the ID field of the mutation.
func withUrgencyLevelID(id int) urgencylevelOption {
	return func(m *UrgencyLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *UrgencyLevel
		)
		m.oldValue = func(ctx context.Context) (*UrgencyLevel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UrgencyLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUrgencyLevel sets the old UrgencyLevel of the mutation.
func withUrgencyLevel(node *UrgencyLevel) urgencylevelOption {
	return func(m *UrgencyLevelMutation) {
		m.oldValue = func(context.Context) (*UrgencyLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UrgencyLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UrgencyLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UrgencyLevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUrgencyName sets the "urgencyName" field.
func (m *UrgencyLevelMutation) SetUrgencyName(s string) {
	m.urgencyName = &s
}

// UrgencyName returns the value of the "urgencyName" field in the mutation.
func (m *UrgencyLevelMutation) UrgencyName() (r string, exists bool) {
	v := m.urgencyName
	if v == nil {
		return
	}
	return *v, true
}

// OldUrgencyName returns the old "urgencyName" field's value of the UrgencyLevel entity.
// If the UrgencyLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrgencyLevelMutation) OldUrgencyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUrgencyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUrgencyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrgencyName: %w", err)
	}
	return oldValue.UrgencyName, nil
}

// ResetUrgencyName resets all changes to the "urgencyName" field.
func (m *UrgencyLevelMutation) ResetUrgencyName() {
	m.urgencyName = nil
}

// AddUrgencyLevelToTriageResultIDs adds the "urgencyLevelToTriageResult" edge to the TriageResult entity by ids.
func (m *UrgencyLevelMutation) AddUrgencyLevelToTriageResultIDs(ids ...int) {
	if m.urgencyLevelToTriageResult == nil {
		m.urgencyLevelToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.urgencyLevelToTriageResult[ids[i]] = struct{}{}
	}
}

// ClearUrgencyLevelToTriageResult clears the "urgencyLevelToTriageResult" edge to the TriageResult entity.
func (m *UrgencyLevelMutation) ClearUrgencyLevelToTriageResult() {
	m.clearedurgencyLevelToTriageResult = true
}

// UrgencyLevelToTriageResultCleared returns if the "urgencyLevelToTriageResult" edge to the TriageResult entity was cleared.
func (m *UrgencyLevelMutation) UrgencyLevelToTriageResultCleared() bool {
	return m.clearedurgencyLevelToTriageResult
}

// RemoveUrgencyLevelToTriageResultIDs removes the "urgencyLevelToTriageResult" edge to the TriageResult entity by IDs.
func (m *UrgencyLevelMutation) RemoveUrgencyLevelToTriageResultIDs(ids ...int) {
	if m.removedurgencyLevelToTriageResult == nil {
		m.removedurgencyLevelToTriageResult = make(map[int]struct{})
	}
	for i := range ids {
		m.removedurgencyLevelToTriageResult[ids[i]] = struct{}{}
	}
}

// RemovedUrgencyLevelToTriageResult returns the removed IDs of the "urgencyLevelToTriageResult" edge to the TriageResult entity.
func (m *UrgencyLevelMutation) RemovedUrgencyLevelToTriageResultIDs() (ids []int) {
	for id := range m.removedurgencyLevelToTriageResult {
		ids = append(ids, id)
	}
	return
}

// UrgencyLevelToTriageResultIDs returns the "urgencyLevelToTriageResult" edge IDs in the mutation.
func (m *UrgencyLevelMutation) UrgencyLevelToTriageResultIDs() (ids []int) {
	for id := range m.urgencyLevelToTriageResult {
		ids = append(ids, id)
	}
	return
}

// ResetUrgencyLevelToTriageResult resets all changes to the "urgencyLevelToTriageResult" edge.
func (m *UrgencyLevelMutation) ResetUrgencyLevelToTriageResult() {
	m.urgencyLevelToTriageResult = nil
	m.clearedurgencyLevelToTriageResult = false
	m.removedurgencyLevelToTriageResult = nil
}

// Op returns the operation name.
func (m *UrgencyLevelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UrgencyLevel).
func (m *UrgencyLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UrgencyLevelMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.urgencyName != nil {
		fields = append(fields, urgencylevel.FieldUrgencyName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UrgencyLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case urgencylevel.FieldUrgencyName:
		return m.UrgencyName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UrgencyLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case urgencylevel.FieldUrgencyName:
		return m.OldUrgencyName(ctx)
	}
	return nil, fmt.Errorf("unknown UrgencyLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UrgencyLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case urgencylevel.FieldUrgencyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrgencyName(v)
		return nil
	}
	return fmt.Errorf("unknown UrgencyLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UrgencyLevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UrgencyLevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UrgencyLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UrgencyLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UrgencyLevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UrgencyLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UrgencyLevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UrgencyLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UrgencyLevelMutation) ResetField(name string) error {
	switch name {
	case urgencylevel.FieldUrgencyName:
		m.ResetUrgencyName()
		return nil
	}
	return fmt.Errorf("unknown UrgencyLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UrgencyLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.urgencyLevelToTriageResult != nil {
		edges = append(edges, urgencylevel.EdgeUrgencyLevelToTriageResult)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UrgencyLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case urgencylevel.EdgeUrgencyLevelToTriageResult:
		ids := make([]ent.Value, 0, len(m.urgencyLevelToTriageResult))
		for id := range m.urgencyLevelToTriageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UrgencyLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedurgencyLevelToTriageResult != nil {
		edges = append(edges, urgencylevel.EdgeUrgencyLevelToTriageResult)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UrgencyLevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case urgencylevel.EdgeUrgencyLevelToTriageResult:
		ids := make([]ent.Value, 0, len(m.removedurgencyLevelToTriageResult))
		for id := range m.removedurgencyLevelToTriageResult {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UrgencyLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedurgencyLevelToTriageResult {
		edges = append(edges, urgencylevel.EdgeUrgencyLevelToTriageResult)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UrgencyLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case urgencylevel.EdgeUrgencyLevelToTriageResult:
		return m.clearedurgencyLevelToTriageResult
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UrgencyLevelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UrgencyLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UrgencyLevelMutation) ResetEdge(name string) error {
	switch name {
	case urgencylevel.EdgeUrgencyLevelToTriageResult:
		m.ResetUrgencyLevelToTriageResult()
		return nil
	}
	return fmt.Errorf("unknown UrgencyLevel edge %s", name)
}
